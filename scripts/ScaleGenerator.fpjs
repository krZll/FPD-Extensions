// Scale engraving example.
// Scale engraving example.


function extend(obj, src) {
    for (var key in src) {
        if (src.hasOwnProperty(key)) obj[key] = src[key];
    }
    return obj;
}

// Needs a focussed frontpanel.
if (!HasFrontpanel())
    Error(_("Bitte erzeugen Sie erst eine Frontplatte."));

// Default settings
var settings = { 
	Shape : 0,
	LinLog: 0,
	Size: 30,
	SAngle: -10,
	EAngle: 190,
	Ticks: 10,
	SubTicks: 4,
	TickLen: 5,
	SubTickLen: 3,
	BaseLine: 1,
	TickLabel: 1,
	LabelDist: 3,
	TickStartValue: 1,
	TickIncrementValue: 1,
	TextSize: 4,
	RotateText: 0
};

// Check if selected object is scale
var sel = frontpanel.Selection();
var is_new = true;
var alt_x = 0, alt_y = 0;
if ( sel.length == 1 && (sel[0].IsGroup() || sel[0].IsHpglEngraving()) ) {
	var ei = sel[0].ExtInfo().split("|&#");
	alt_x = sel[0].X(); alt_y = sel[0].Y();
	if (ei.length == 2 && ei[0] == "ScaleGen") {
		settings = extend( settings, eval(ei[1]) );
		is_new = false;
	}
}

// Dialog for settings
var dia = new Dialog(_("Skala erstellen"));

var p_shape = new Param(settings["Shape"]);
var p_linlog = new Param(settings["LinLog"]);
var p_startangle = new Param(settings["SAngle"]);
var p_endangle = new Param(settings["EAngle"]);
var p_size = new Param(settings["Size"]);
var p_ticks = new Param(settings["Ticks"]);
var p_subticks = new Param(settings["SubTicks"]);
var p_ticklen = new Param(settings["TickLen"]);
var p_subticklen = new Param(settings["SubTickLen"]);
var p_baseline = new Param(settings["BaseLine"]);
var p_ticklabel = new Param(settings["TickLabel"]);
var p_labeldist = new Param(settings["LabelDist"]);
var p_tickstartvalue = new Param(settings["TickStartValue"]);
var p_tickincrementvalue = new Param(settings["TickIncrementValue"]);
var p_textsize = new Param(settings["TextSize"]);
var p_rotatetext = new Param(settings["RotateText"]);
dia.VSpacer(5).Newline().Spacer(10);
dia.Box().NewlineC();

if (is_new) {
	dia.Text(__("Neue Skala erstellen:|Choose parameters for scale:|Choisir des parametres pour la gravure:"));
} else {
	dia.Text(_("Ausgewählte Skala bearbeiten"));
}

dia.VSpacer(5).NewlineC().Divider().VSpacer(10).NewlineC();

dia.RadioBox(p_shape, _("Form der Skala:\nRund\nLinear")).Spacer(25).NewlineC();

dia.RadioBox(p_linlog, _("Skalierung:\nLinear\nLogarithmisch")).Spacer(25).NewlineC();

dia.VSpacer(10).BoxC().NewlineC();
dia.Text(_("Radius bzw. Länge:")).SpinValue(p_size, 0, 10000, 1).Spacer(3).Text(__("mm"));
dia.VSpacer(5).NewlineC();
dia.Text(_("Anfangswinkel:")).SpinValue(p_startangle, -360, 360, 5).Spacer(3).Text(__("deg"));
dia.VSpacer(5).NewlineC();
dia.Text(_("Endwinkel:")).SpinValue(p_endangle, -360, 360, 5).Spacer(3).Text(__("deg"));
dia.EndBox().NewlineC();


dia.VSpacer(5).NewlineC();
dia.BoxC().NewlineC();
dia.Text(_("Anzahl Skalenstriche:")).SpinValue(p_ticks, 0, 10000, 1);
dia.VSpacer(5).NewlineC();
dia.Text(_("Anzahl Teilstriche:")).SpinValue(p_subticks, 0, 10000, 1);
dia.VSpacer(15).EndBox();


dia.BoxC().NewlineC();
dia.Spacer(8).Text(_("Länge:"));
dia.SpinValue(p_ticklen, 0, 10000, 1).Spacer(3).Text(__("mm"));
dia.Spacer(12).VSpacer(5).NewlineC();
dia.Spacer(8).Text(_("Länge:"));
dia.SpinValue(p_subticklen, 0, 10000, 1).Spacer(3).Text("mm");
dia.Spacer(12).VSpacer(15).EndBox().NewlineC();


dia.BoxC().NewlineC();
dia.CheckBox(p_baseline, _("Grundlinie zeichnen"))
dia.VSpacer(15).EndBox().NewlineC();

dia.Divider().NewlineC();

dia.BoxC().VSpacer(15).NewlineC();
dia.CheckBox(p_ticklabel, _("Beschriftung hinzufügen:"));
dia.VSpacer(10).EndBox().NewlineC();

//dia.BoxC().NewlineC().VSpacer(10);
//dia.Text(__("(Die nachfolgenden Optionen sind nur gültig wenn 'Beschriftung hinzufügen' ausgewählt wurde.)"));
//dia.EndBox().NewlineC();

dia.BoxC().NewlineC().Text(_("Anfangswert:"));
dia.SpinValue(p_tickstartvalue, -2000000000000, 2000000000000, 1);
dia.Spacer(8).Text(_("Inkrement:"));
dia.SpinValue(p_tickincrementvalue, -2000000000000, 2000000000000, 1);
dia.EndBox().NewlineC();


dia.BoxC().VSpacer(5).NewlineC().Text(_("Abstand Beschriftung:"));
dia.SpinValue(p_labeldist, 0, 10000, 1).Spacer(3).Text("mm");
dia.VSpacer(5).NewlineC();
dia.Text(_("Textgröße:")).SpinValue(p_textsize, 0.1, 10000, 0.5)
dia.Spacer(3).Text(_("mm"));
dia.VSpacer(5).NewlineC();
dia.CheckBox(p_rotatetext, _("Text drehen (bei runden Skalen)"));
dia.VSpacer(10).NewlineC();
dia.VSpacer(10).EndBox();

dia.NewlineC();
dia.Divider().NewlineC();
dia.BoxC().VSpacer(10).NewlineC();
dia.Spacer(0).DlgButton(0, _("Abbruch")).Spacer(5).DlgButton(1, _("Ok")).Spacer(0);
dia.EndBox().Spacer(10).VSpacer(10);

if (1 == dia.Show()) {	// "Ok" button pressed
	var shape = p_shape.get();
	var linlog = p_linlog.get();
	var size = p_size.get();
	var startangle = p_startangle.get();
	var endangle = p_endangle.get();
	var numticks = p_ticks.get();
	var numsubticks = p_subticks.get();
	var size = p_size.get();
	var ticklen = p_ticklen.get();
	var subticklen = p_subticklen.get();
	var baseline = p_baseline.get();
	var ticklabel = p_ticklabel.get();
	var labeldist = p_labeldist.get();
	var tickstartvalue = p_tickstartvalue.get();
	var tickincrementvalue = p_tickincrementvalue.get();
	var textsize = p_textsize.get();
	var rotatetext = p_rotatetext.get();
	
	var angle = endangle - startangle;
	// in this case we do not draw the last line and label
	var fullCircle = false;

	if(shape == 0) {
		if (angle > 360 || angle < -360) {
			Error("angle");
		}
		if(angle == 360 || angle == -360) {
			fullCircle = true;
		}
	}
		
	if (ticklabel) {
		var g = new Group("scale");
	}

	var hpgl = new HpglEngraving("hpgl-canvas1", "", hpgl_center, 100, 0, 0);
	hpgl.SetRefPoint(hpgl_file);
	frontpanel.AddElement(hpgl,0,0);
	var pen_tick =  0;
	if (numsubticks > 0) var pen_subtick = hpgl.DefinePen(engrave_jet_black, engraver_0_2mm);
	var pen_base = hpgl.DefinePen(engrave_jet_black, engraver_0_2mm);
	if (shape == 0) {

		
		// Round scale
	    	var phi = (endangle - startangle) * Math.PI / 180;
		var sub_phi = phi / (numticks - 1);
		var start_phi = startangle * Math.PI /180;   

		var x_start, y_start;
		var akt_phi;
		for (i = 0; i < numticks; ++i) {
			if (linlog == 0) {
				akt_phi = start_phi + (phi * i / (numticks-1));
			} else {
				akt_phi = start_phi + phi * Math.log(1 + 9 * i / (numticks-1) ) / Math.log(10);
			}
			var x_n = -Math.cos(akt_phi);
			var y_n = Math.sin(akt_phi);
			var x = x_n * size; var y= y_n * size;
			if (i == 0) {
				x_start = x; y_start = y;
			}
			hpgl.ChangePen(pen_tick);
			hpgl.Start(x,y);
			hpgl.LineTo(x_n * (size + ticklen), y_n * (size + ticklen));
			hpgl.Finish();
			if (ticklabel && !(fullCircle && i == numticks - 1)) {
				var t = new TextEngraving("", tickstartvalue + i*tickincrementvalue);
				t.SetAlignment(align_center);
				t.SetTextSize(textsize);
				if(rotatetext){
					t.Rotate( 90 - akt_phi*180/Math.PI );
				}
				frontpanel.AddElement(t,x_n * (size + ticklen + labeldist), y_n * (size + ticklen + labeldist));
				g.AddElement(t);
			}
			if ( i < (numticks-1) ) {
				var akt_sphi;
				for (j=0; j<numsubticks; j++) {
					if (linlog == 0) {			
						akt_sphi = akt_phi + sub_phi * (j+1) / (numsubticks +1);
					} else {
						akt_sphi = start_phi + phi * Math.log( 1 + 9 * (i + (j+1) / (numsubticks +1)) / (numticks-1) ) / Math.log(10);
					}
					var sx_n = -Math.cos(akt_sphi);
					var sy_n = Math.sin(akt_sphi);
					hpgl.ChangePen(pen_subtick);
					hpgl.Start(sx_n * size, sy_n * size);
					hpgl.LineTo(sx_n * (size + subticklen), sy_n * (size + subticklen));
					hpgl.Finish();
				}
			}
		}
	} else {
		// Linear scale
		x_start = y_start = 0;
		var x;
		for (i = 0; i < numticks; ++i) {
			if (linlog == 0) {
				x = i * size / (numticks-1);
			} else {
				x = size * Math.log(1 + (9) * i / (numticks-1) ) / Math.log(10);
			}
			hpgl.ChangePen(pen_tick);
			hpgl.Start(x,0);
			hpgl.LineTo(x, ticklen);
			hpgl.Finish();
			if (ticklabel) {
				var t = new TextEngraving("", tickstartvalue + i*tickincrementvalue);
				t.SetTextSize(textsize);
				t.SetAlignment(align_center);
				frontpanel.AddElement(t, x, ticklen + labeldist);
				g.AddElement(t);
			}
			if ( i < (numticks-1) ) {
				for (j=0; j<numsubticks; j++) {
					if (linlog == 0) {			
						sx = size * (i + (j+1) / (numsubticks +1)) / (numticks-1);
					} else {
						sx = size *  Math.log( 1 + 9 * (i + (j+1) / (numsubticks +1)) / (numticks-1) ) / Math.log(10);
					}
					hpgl.ChangePen(pen_subtick);
					hpgl.Start(sx, 0);
					hpgl.LineTo(sx, subticklen);
					hpgl.Finish();
				}
			}
		}
		
	}
	if (baseline) {
		hpgl.ChangePen(pen_base);
		hpgl.Start(x_start, y_start);
		if (shape == 0) {
			if(fullCircle) {
				hpgl.ArcToMP(-x,-y, 0,0, (startangle > endangle)?1:0);
				hpgl.ArcToMP(x,y, 0,0, (startangle > endangle)?1:0);
			}
			else {
				hpgl.ArcToMP(x,y, 0,0, (startangle > endangle)?1:0);
			}
		} else {
			hpgl.LineTo(size,0);
		}			
		hpgl.Finish();
	}
	var element = hpgl;
	if (ticklabel) {
		g.AddElement(hpgl);
		g.SetRefElement(hpgl);
		frontpanel.AddElement(g,0,0);
		element = g;
	}
	
	// Save settings to ExtInfo
	settings["Shape"] = shape;
	settings["LinLog"] = linlog;
	settings["SAngle"] = startangle;
	settings["EAngle"] = endangle;
	settings["Size"] = size;
	settings["Ticks"] = numticks;
	settings["SubTicks"] = numsubticks;
	settings["TickLen"] = ticklen;
	settings["SubTickLen"] = subticklen;
	settings["BaseLine"] = baseline;
	settings["TickLabel"] = ticklabel;
	settings["LabelDist"] = labeldist;
	settings["TickStartValue"] = tickstartvalue;
	settings["TickIncrementValue"] = tickincrementvalue;
	settings["TextSize"] = textsize;
	settings["RotateText"] = rotatetext; 
	element.SetExtInfo("ScaleGen|&#"+settings.toSource());
	if (!is_new) {
		frontpanel.RemoveElement(sel[0]);
	}
	element.MoveTo(alt_x, alt_y);
	frontpanel.SelectElement(element);
}
