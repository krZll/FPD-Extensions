/***************************************************************
 *  (c) 2013-2015 SKAARHOJ K/S, www.skaarhoj.com
 *  Author: Kasper Skårhøj <kasper@skaarhoj.com>
 *
 *  This script is Open Source under GNU/GPL license. 
 *  See bottom for more details.
 *
 *  Licensed to Schaeffer AG for inclusion with Front Panel Designer.
 ***************************************************************/
/*************************************************************
 * This is a JavaScript program written for a software called 
 * Front Panel Designer made by Schaeffer AG. 
 * Front Panel Designer is a CAD application for design and 
 * online ordering of aluminum panels and this script will create 
 * several such panels based on input parameters. The panels will 
 * form a full enclosure when assembled.
 *
 * The enclosures are based on the Housing Manual by Schaeffer AG.
 * Some features are added and modified by SKAARHOJ K/S.
 *
 * See http://skaarhoj.com/schaeffer/ for latest version, other
 * tools and training resources published by SKAARHOJ K/S.
 *
 * - kasper
 **************************************************************/



// Set this to "false" if you want to manually adjust parameters below:
var C_UI = true;



/***************************************
 * Global Settings for enclosure creation.
 * Adapt to your needs for full flexibility
 * (Alternatively, use the preset functions below)
 *
 * All measures in mm. (25.4 mm = 1 inch)
 ***************************************/

// ENCLOSURE TYPE
// 1 = based on side sections (results in 4 panels)
// 2 = based on housing profiles (results in 6 panels)
var C_type = 2;

// For C_type==1: Side section 1 (42mm high) or 2 (56mm high)?
var C_sideSectionType = 1;

// For C_type==2: Determines if housing profile 2 is used on a given side.
// Notice: If set true for a given side, any adjacent sides CANNOT be true as well!
// For instance, it can be true for Top and Bottom or Left and Right, but not Top and Left
var C_housingProfile2Top = false;
var C_housingProfile2Left = false;
var C_housingProfile2Right = false;
var C_housingProfile2Bottom = false;

// WIDTH, HEIGHT, DEPTH of enclosure (outer measures):
// For C_type==1: Height will be overruled by the height of the chosen side section type 1 (42mm) or 2 (56mm).
var C_width = 100;
var C_height = 60;	
var C_depth = 80;

// Thickness of plates: 2, 2.5, 3, 4
var C_thickness = new Array(
		4, 		// Front
		2.5, 	// Top
		2.5, 	// Back
		2.5, 	// Bottom
		2.5, 	// Left (For C_type==2 only)
		2.5		// Right (For C_type==2 only)
	);

// Colors: These are constants from Schaeffers Scripting API manual
var C_color = new Array(
		elox_blue, 		// Front
		elox_blue, 		// Top
		elox_natural, 	// Back
		elox_blue, 		// Bottom
		elox_blue, 		// Left (For C_type==2 only)
		elox_blue		// Right (For C_type==2 only)
	);

// Housing Brackets:   	
var C_numberOfHousingBracketsFront = new Array(0,0,0,0); // (Top, Bottom, Left, Right). Defines the number of housing brackets used on the front for each side panel. -1 will automatically place them pr. C_housingBracketMaxDistance mm.
var C_numberOfHousingBracketsBack = new Array(0,0,0,0);  // (Top, Bottom, Left, Right). Defines the number of housing brackets used on the back for each side panel.  -1 will automatically place them pr. C_housingBracketMaxDistance mm.
var C_housingBracketMaxDistance = 150;	// The maximum distance between automatically placed housing brackets
var C_useStudsForHousingBracketsOnFront = false;	// Uses M3x8mm Studs for housing brackets on front (instead of countersunk holes). Notice: This requires you to drill the thread out of the housing brackets on one side and use a washer and nut to fasten it!
var C_useStudsForHousingBracketsOnBack = false;	// Same as above, but for the back.

// Front and Back Assembly Slots:
var C_useAssemblySlotsFront = new Array(true, true, true, true);	// (Top, Bottom, Left, Right). If true, cavities are used on the front panel to fit the top, bottom, left and right plates.
var C_useAssemblySlotsBack = new Array(true, true, true, true);	// (Top, Bottom, Left, Right). If true, cavities are used on the back panel to fit the top, bottom, left and right plates.
var C_depthOfCavitiesForSlotsFront = new Array(1,1,1,1);	// (Top, Bottom, Left, Right). Depth of cavity in top/bottom/left/right plates, front side
var C_depthOfCavitiesForSlotsBack = new Array(1,1,1,1);	// (Top, Bottom, Left, Right). Depth of cavity in top/bottom/left/right plates, back side
var C_assemblySlotDepthFront = new Array(1.5,1.5,1.5,1.5);	// (Top, Bottom, Left, Right). Assembly Slot Depths, front side
var C_assemblySlotDepthBack = new Array(1,1,1,1);				// (Top, Bottom, Left, Right). Assembly Slot Depths, back side

// Ordering
var C_createOrder = false;			// If true, will create an order and add the accessories (profiles, assembly kits etc.)
var C_orderBlackItems = false;		// If true, will order accessories in black instead of natural color.
var M3count = 0;

// Additional features:
var C_extraFrontWidth = 0;	// If greater than zero, it will add this amount of space on left and right side of the front panel. This is useful to create "rack ears" (see also "C_rackEars" setting). If you want to create a true 19" unit, make sure 2* this value + C_width equals 483mm. A good choice is to set this value at 23mm and C_width = 437 => 23*2+437=483mm
var C_extraFrontHeight = 0;	// If creating a 1U rack unit, 43.60mm is a typical choice for the total height, so add 1.6 in total by setting this value to 0.8. (1U = 44.45mm or 1.75inch)
var C_rackEars = false;			// If true, adds holes for rack mounting. See also "C_extraFrontWidth"
var C_roundFrontCorners = true;	// If true, corners of the front panel are rounded by 2mm which fits the side or housing profiles.
var C_addEdgeGrinding = false;	// You probably want edges grinded on the end profiles (front and back) if you are not making a rack unit! Otherwise they are ugly from tool marks and often very sharp.
var C_addGuideEngravings = true;	// This will add thin, orange engraved lines for preview of where adjacent components (panels, profiles and brackets) are located on each side. Can be useful for positioning other elements after which they should be removed before ordering.

var C_panelNamesPrefix = "";		// A panel name prefix
var C_panelNamesSuffix = "";		// A panel name suffix

// Exotic features:
var C_sideExpansionOffset = new Array(0,0,0,0); // (Top, Bottom, Left, Right). This offsets the top, bottom, left and right plates outwards if positive. By default the top and bottom plates are placed so their outer surface is flush with the side/housing profiles. When used with housing profile 1 this value should probably be -1!
var C_housingProfileRightHeight = 0;	// Must be less than C_height. If zero = off. Imposes various restrictions on the bottom plate, among other that it has to be bent a bit. So this is a special case. Also, cannot be used with housing brackets on the bottom plate (front and back).

var C_dryRun = false;		// If set, the script will render only the "Front" panel

//distributes the cavity tolerance to the upper and lower cavity.
//four Modes here Side_Cavity_Tolerance_Mode: 
//1: all tolerance added to upper cavity (simplest)
//2: all tolerance added to under cavity if presented
//3: tolerance added equally to cavities if undercavity presented
//4: distributed in linear ratio
var Side_Cavity_Tolerance_Mode = 4;





/***************************************
 * Presets
 *
 * These functions will set groups of the global
 * settings based on a more simple input.
 *
 * Uncomment the one you want to use and 
 * configure the argument values
 ***************************************/

// preset_sideProfileBox(1, 200, 100, elox_blue);	// profile, width, depth, color
// preset_1UnitEnclosure(134, elox_blue);
// preset_housingProfileBox(100, 50, 80, elox_blue);
// preset_rackUnitBox(3, 70, elox_black);
// preset_console(108, 60, 40, 135+4+4, elox_blue);
// preset_test();






if (C_UI)	{
		// The variables C_SchaefferHousings_UI_* hold the values for re-use in the interface box. Here they are given the initial value
	if (typeof C_SchaefferHousings_UI_type === 'undefined') {
		var C_SchaefferHousings_UI_type = C_type;
	}
	if (typeof C_SchaefferHousings_UI_width === 'undefined') {
		var C_SchaefferHousings_UI_width = C_width;
	}
	if (typeof C_SchaefferHousings_UI_height === 'undefined') {
		var C_SchaefferHousings_UI_height = C_height;
	}
	if (typeof C_SchaefferHousings_UI_depth === 'undefined') {
		var C_SchaefferHousings_UI_depth = C_depth;
	}
	if (typeof C_SchaefferHousings_UI_color === 'undefined') {
		var C_SchaefferHousings_UI_color = 0;
	}
	if (typeof C_SchaefferHousings_UI_sideSectionHeight === 'undefined') {
		var C_SchaefferHousings_UI_sideSectionHeight = 0;
	}
	if (typeof C_SchaefferHousings_UI_rack === 'undefined') {
		var C_SchaefferHousings_UI_rack = 0;
	}
	if (typeof C_SchaefferHousings_UI_thickness === 'undefined') {
		var C_SchaefferHousings_UI_thickness = 1;
	}
	if (typeof C_SchaefferHousings_UI_kitcolor === 'undefined') {
		var C_SchaefferHousings_UI_kitcolor = 0;
	}
	if (typeof C_SchaefferHousings_UI_housingBrackets === 'undefined') {
		var C_SchaefferHousings_UI_housingBrackets = 0;
	}
	if (typeof C_SchaefferHousings_UI_guideObjects === 'undefined') {
		var C_SchaefferHousings_UI_guideObjects = 1;
	}
	if (typeof C_SchaefferHousings_UI_dryRun === 'undefined') {
		var C_SchaefferHousings_UI_dryRun = 0;
	}
        if (typeof C_SchaefferHousings_UI_HProfile === 'undefined') {
		var C_SchaefferHousings_UI_HProfile = 3;
	}
	
	
	showUI();

		// The variables C_SchaefferHousings_UI_* hold the values for re-use in the interface box. Here they are given the latest value
	C_SchaefferHousings_UI_type = C_type;
	C_SchaefferHousings_UI_width = C_width;
	C_SchaefferHousings_UI_height = C_height;
	C_SchaefferHousings_UI_depth = C_depth;
	// C_SchaefferHousings_UI_color is set inside showUI();
	// C_SchaefferHousings_UI_sideSectionHeight (same)
	// C_SchaefferHousings_UI_rack (same)
	// C_SchaefferHousings_UI_thickness (same)
	// C_SchaefferHousings_UI_kitcolor (same)
	// C_SchaefferHousings_UI_housingBrackets (same)
	// C_SchaefferHousings_UI_guideObjects (same)
	// C_SchaefferHousings_UI_dryRun (same)
	
}



// ###MARKER_POSTCONFIG###


/**********************************************************************
 * NO USER SETTING BELOW!
 **********************************************************************/






function showUI()	{
	
        var d = new Dialog(_("Enclosure Type"),300,200); // create the dialog window
	d.Newline().VSpacer(0).NewlineC();
	
	var enclosureType = new Param(C_SchaefferHousings_UI_type-1);
	d.Spacer(25).Text(_("Choose type of enclosure:")).NewlineC();
	d.Spacer(25).RadioBox(enclosureType, _(" \nHousing with side profiles\nHousing with enclosure profiles")).Spacer(25).Newline();
	d.VSpacer(10).NewlineC();
	d.Spacer(25).Text(_("More information on enclosures:")).NewlineC();
	d.Spacer(25).Text(_("https://www.schaeffer-ag.de/en/housings"));
	d.NewlineC().VSpacer(10).NewlineC();
	d.Divider().NewlineC();

	// And an "Ok" button, which, when pressed, will close
	// the dialog, returning 1 from Show().
	d.Spacer(0).DlgButton(1, _("Ok!")).Spacer(0);
	// Show dialog, pressed button is returned but not used
	// in this example.
	var b = d.Show();
	
	if(b==0) {
		Print(_("Script execution cancelled due to user request"));
		Halt();
	}
	                                 
	
	C_type = enclosureType.get()+1; 
	var HProfileCodes = new Array (1,2,3);
    var HProfile = new Param(C_SchaefferHousings_UI_HProfile-1);
	
	if (enclosureType.get()+1==1)	{
		var d = new Dialog(_("Housing with side profiles"),500,100); // create the dialog window
		d.Newline().VSpacer(0).NewlineC();

		var sideSectionHeight = new Param(C_SchaefferHousings_UI_sideSectionHeight);
		d.Spacer(25).Text(_("Height:"));
		d.Spacer(6).RadioBox(sideSectionHeight, _(" \nSide Section 1 (42 mm)\nSide Section 2 (56mm)")).Spacer(0).NewlineC();
	} else if (enclosureType.get()+1==2)	{
		var d = new Dialog(_("Housing with enclosure profiles"),500,100); // create the dialog window
		d.Newline().VSpacer(10).NewlineC();
		
		d.VSpacer(10).Newline();
        
        if (enclosureType.get()+1==2)	{
            d.Spacer(25).Text(_("Housing Profile:")).NewlineC();
            d.Spacer(25).RadioBox(HProfile, _(" Type \nHP 1 (slot panels) \nHP 2 (screw in top/bottom panels) \nHP 1 and 2 combo")).Newline();
			d.Spacer(25).NewlineC(); //no difference...
			d.VSpacer(20).Newline();
			//https://www.schaeffer-ag.de/fileadmin/user_upload/Downloads/Handbuecher_Datenblaetter/PDFs/Housingassemblymanual.pdf
		}

	
		var height = new Param(C_SchaefferHousings_UI_height.toString());
		d.Spacer(25).Text(_("Height:"));
		d.Spacer(10).TextEntry(1, height).Spacer(5).Text(_("mm")).Spacer(0).NewlineC();
	}
	

	
	var width = new Param(C_SchaefferHousings_UI_width.toString());
	d.Spacer(25).Text(_("Width:"));
	d.Spacer(13).TextEntry(1, width).Spacer(5).Text(_("mm")).Spacer(0).NewlineC();

	var rack = new Param(C_SchaefferHousings_UI_rack);
	if (enclosureType.get()+1==1)	{
		d.Spacer(25).CheckBox(rack, _("Make it a Rack Unit? (overrides Width)")).Spacer(5).NewlineC();
	} else if (enclosureType.get()+1==2)	{
		d.Spacer(25).Text(_("Rack Unit:")).Spacer(5).RadioBox(rack,_(" \nNone\n1U Rack Unit\n2U Rack Unit\n3U Rack Unit")).Spacer(5).Text(_("(Overrides width/height)")).Spacer(0).NewlineC();
	}

        var depth = new Param(C_SchaefferHousings_UI_depth.toString());
        d.Spacer(25).Text(_("Depth:"));
	d.Spacer(10).TextEntry(1, depth).Spacer(5).Text(_("mm")).Spacer(0).NewlineC();
	
	var thickness = new Param(C_SchaefferHousings_UI_thickness);
	d.Spacer(25).Text(_("Thickness of panels:")).NewlineC();
	d.Spacer(25).RadioBox(thickness, _(" \n 2 mm \n2.5 mm\n3 mm\n4 mm")).Spacer(0).NewlineC();
	var thicknessCodes = new Array(2,2.5,3,4);

	d.VSpacer(20).Newline();
	var color = new Param(C_SchaefferHousings_UI_color);
	d.Spacer(25).Text(_("Color of panels:")).NewlineC();
	d.Spacer(25).RadioBox(color, _(" \nNatural\nGold\nRed\nBlue\nGreen\nMedium bronze\nBlack")).Spacer(25).NewlineC();
	var colorCodes = new Array(elox_natural,elox_gold,elox_red,elox_blue,elox_green,elox_medium_bronze,elox_black);

	d.VSpacer(20).Newline();
	var kitcolor = new Param(C_SchaefferHousings_UI_kitcolor);
	d.Spacer(25).Text(_("Color of screws/profiles:")).NewlineC();
	d.Spacer(25).RadioBox(kitcolor, _(" \n(No kit)\nNatural\nBlack")).Spacer(25).NewlineC();

	d.VSpacer(20).Newline();

	var housingBrackets = new Param(C_SchaefferHousings_UI_housingBrackets);
	d.Spacer(25).CheckBox(housingBrackets, _("Add housing brackets?")).NewlineC();

	var guideObjects = new Param(C_SchaefferHousings_UI_guideObjects);
	d.Spacer(25).CheckBox(guideObjects, _("Add guide engravings?")).NewlineC();

    var useStuds = C_useStudsForHousingBracketsOnFront ? 1 : 0;
        //? (C_useStudsForHousingBracketsOnFront) ius = 0 : ius = 0;
        //var
    useStuds = new Param(useStuds);
    d.Spacer(25).CheckBox(useStuds, _("Avoid FrontPanel Drillholes (use Studs)")).NewlineC();

	var dryRun = new Param(C_SchaefferHousings_UI_dryRun);
	d.Spacer(25).CheckBox(dryRun, _("Test run (Only Front panel rendered)")).NewlineC();

	d.Divider().NewlineC();

	// And an "Ok" button, which, when pressed, will close
	// the dialog, returning 1 from Show().
	d.Spacer(0).DlgButton(1, _("Create!")).Spacer(0);
	// Show dialog, pressed button is returned but not used
	// in this example.
	var b = d.Show();
	
	if(b==0) {
		Print(_("Script execution cancelled due to user request"));
		Halt();
	}
	
	C_SchaefferHousings_UI_color = color.get();
	if (typeof sideSectionHeight !== 'undefined') {
		C_SchaefferHousings_UI_sideSectionHeight = sideSectionHeight.get();
	}
	C_SchaefferHousings_UI_rack = rack.get();
	C_SchaefferHousings_UI_thickness = thickness.get();
	C_SchaefferHousings_UI_kitcolor = kitcolor.get();
	C_SchaefferHousings_UI_housingBrackets = housingBrackets.get();
	C_SchaefferHousings_UI_guideObjects = guideObjects.get();
	C_SchaefferHousings_UI_dryRun = dryRun.get();
        C_SchaefferHousings_UI_HProfile = HProfileCodes[HProfile.get()];

		//This section determines the screw vs slot usage
        //((C_SchaefferHousings_UI_HProfile=1;
        if (C_SchaefferHousings_UI_HProfile == 1) {
            C_housingProfile2Top = false;
            C_housingProfile2Left = false;
            C_housingProfile2Right = false;
            C_housingProfile2Bottom = false;
        } else if (C_SchaefferHousings_UI_HProfile == 2) {
            C_housingProfile2Top = false;
            C_housingProfile2Left = true;
            C_housingProfile2Right = true;
            C_housingProfile2Bottom = false;

        } else {
            C_housingProfile2Top = true;
            C_housingProfile2Left = false;
            C_housingProfile2Right = false;
            C_housingProfile2Bottom = false;
        }

	
	// Transferring values from UI to global variables:
	Print(_("\n\nConfiguration values:\n"));
	switch(C_type)	{
	case 1:
		C_sideSectionType = sideSectionHeight.get()+1;
		Print("C_sideSectionType="+C_sideSectionType+"\n")
		break;
	case 2:
		C_height = parseFloat(height.get());
		Print("C_height="+C_height+"\n")
		break;		
	}
	C_width = parseFloat(width.get());
	C_depth = parseFloat(depth.get());

	if (rack.get())	{
		C_width = 437;
		C_extraFrontWidth = 23;
		C_rackEars = true;
		Print("C_extraFrontWidth="+C_extraFrontWidth+"\n")
		Print("C_rackEars="+(C_rackEars?_("Yes"):_("No"))+"\n")
		switch(C_type)	{
			case 1:
				C_extraFrontHeight = 0.8;
				C_sideExpansionOffset = new Array(0.25,0.25,0,0);
			break;
			case 2:
				C_height = rack.get()*1.75*25.4-0.5;
				//Next command line was probably written before we had various housing profiles
				//causing glitches together with hp2 (trying to insert screws an 3 sides!) 
				//or is not fitting the order script with screws & stuff.
				//when intended to have all racks with combo profile, C_SchaefferHousings_UI_HProfile must be 3.
				
				//C_housingProfile2Top = true;
			break;
		
		}
	}
	Print("C_width="+C_width+"\n")
	Print("C_depth="+C_depth+"\n")

	C_thickness = new Array(
		thicknessCodes[thickness.get()],
		thicknessCodes[thickness.get()],
		thicknessCodes[thickness.get()],
		thicknessCodes[thickness.get()],
		thicknessCodes[thickness.get()],
		thicknessCodes[thickness.get()]
	);
	Print("C_thickness=["+C_thickness+"]\n")

	C_color = new Array(
		colorCodes[color.get()],
		colorCodes[color.get()],
		colorCodes[color.get()],
		colorCodes[color.get()],
		colorCodes[color.get()],
		colorCodes[color.get()]
	);
	Print("C_color=["+C_color+"]\n")
	
	if (housingBrackets.get())	{
		C_numberOfHousingBracketsFront = new Array(-1,-1,-1,-1);
		C_numberOfHousingBracketsBack = new Array(-1,-1,-1,-1);
		Print(_("Housing Brackets=Yes\n"));
	}
	
	if (kitcolor.get())	{
		C_createOrder = true;
		C_orderBlackItems = kitcolor.get()==2 ? true : false;
		Print("C_orderBlackItems="+(C_orderBlackItems?_("Yes"):_("No"))+"\n")
	}

    C_useStudsForHousingBracketsOnFront = useStuds.get() ? true : false;
	
	C_addGuideEngravings = guideObjects.get() ? true : false;
	Print("C_addGuideEngravings="+(C_addGuideEngravings?_("Yes"):_("No"))+"\n")

	C_dryRun = dryRun.get() ? true : false;
	Print("C_dryRun="+(C_dryRun?_("Yes"):_("No"))+"\n")
	
	C_useAssemblySlotsFront = new Array(false, false, false, false);
	C_useAssemblySlotsBack = new Array(false, false, false, false);	
}


/***************************************
 * Presets functions
 ***************************************/
function preset_sideProfileBox(profile, width, depth, color)	{
	C_type = 1;
	C_sideSectionType = profile==1 ? 1 : 2;

	C_width = width;
	C_depth = depth;
	
	C_color = new Array(
			color, 		// Front
			color, 		// Top
			elox_natural, 	// Back
			color, 		// Bottom
			color,
			color
		);

}
function preset_1UnitEnclosure(depth, color) {
	C_type = 1;
	C_sideSectionType = 1;

	C_depth = depth;
	C_width = 437;

	C_color = new Array(
			color, 		// Front
			color, 		// Top
			elox_natural, 	// Back
			color, 		// Bottom
			color,
			color
		);
		
	C_extraFrontHeight = 0.8;
	C_extraFrontWidth = 23;
	C_rackEars = true;
	C_roundFrontCorners = false;
	
	C_sideExpansionOffset = new Array(0.25,0.25,0,0);	
}
function preset_housingProfileBox(width, height, depth, color) {
	C_type = 2;
	
	C_width = width;
	C_height = height;
	C_depth = depth;
	
	C_color = new Array(
			color, 		// Front
			color, 		// Top
			elox_natural, 	// Back
			color, 		// Bottom
			color, 		// Left (For C_type==2 only)
			color		// Right (For C_type==2 only)
		);
	
	C_housingProfile2Top = true;
	C_sideExpansionOffset = new Array(0,-1,-1,-1);
}
function preset_rackUnitBox(U_height, depth, color) {
	C_type = 2;
	
	C_width = 437;
	C_height = U_height*1.75*25.4-0.5;
	C_depth = depth;
	
	C_extraFrontWidth = 23;
	C_rackEars = true;
	C_roundFrontCorners = false;
		
	C_color = new Array(
			color, 		// Front
			color, 		// Top
			elox_natural, 	// Back
			color, 		// Bottom
			color, 		// Left (For C_type==2 only)
			color		// Right (For C_type==2 only)
		);
	
	C_housingProfile2Top = true;

	C_numberOfHousingBracketsFront = new Array(3,3,0,0);
	C_numberOfHousingBracketsBack = new Array(3,3,0,0);
	C_useAssemblySlotsFront = new Array(true, true, false, false);	// (Top, Bottom, Left, Right).
	C_useAssemblySlotsBack = new Array(false, false, false, false);	// (Top, Bottom, Left, Right).
}
function preset_console(width, height, height_front, depth, color) {
	C_type = 2;
	
	C_width = width;
	C_height = height;
	C_depth = depth;
	
	C_color = new Array(
			elox_natural, 		// Front
			color, 		// Top
			elox_natural, 	// Back
			color, 		// Bottom
			color, 		// Left (For C_type==2 only)
			color		// Right (For C_type==2 only)
		);
	C_thickness = new Array(
			4, 		// Front
			4, 	// Top
			4, 	// Back
			2.5, 	// Bottom
			2.5, 	// Left (For C_type==2 only)
			2.5		// Right (For C_type==2 only)
		);
	
	C_sideExpansionOffset = new Array(-1,-1,-1,-1);
	C_housingProfileRightHeight = height_front;
	
	C_depthOfCavitiesForSlotsFront = new Array(0,0,0,0);	// (Top, Bottom, Left, Right). 
	C_depthOfCavitiesForSlotsBack = new Array(0,0,0,0);	// (Top, Bottom, Left, Right). 

	C_assemblySlotDepthFront = new Array(1,1,1,1);
	C_assemblySlotDepthBack = new Array(1,1,1,1);
}
function preset_test() {
	
	// ENCLOSURE TYPE
	// 1 = based on side sections (results in 4 panels)
	// 2 = based on housing profiles (results in 6 panels)
	C_type = 2;

	// For C_type==1: Side section 1 (42mm high) or 2 (56mm high)?
	C_sideSectionType = 1;

	// For C_type==2: Determines if housing profile 2 is used on a given side.
	// Notice: If set true for a given side, any adjacent sides CANNOT be true as well!
	// For instance, it can be true for Top and Bottom or Left and Right, but not Top and Left
	C_housingProfile2Top = true;
	C_housingProfile2Left = false;
	C_housingProfile2Right = false;
	C_housingProfile2Bottom = true;

	// WIDTH, HEIGHT, DEPTH of enclosure (outer measures):
	// For C_type==1: Height will be overruled by the height of the chosen side section type 1 (42mm) or 2 (56mm).
	C_width = 100;
	C_height = 50;	
	C_depth = 80;

	// Thickness of plates: 2, 2.5, 3, 4
	C_thickness = new Array(
			4, 		// Front
			2.5, 	// Top
			2.5, 	// Back
			2.5, 	// Bottom
			2, 	// Left (For C_type==2 only)
			3		// Right (For C_type==2 only)
		);

	// Colors: These are constants from Schaeffers Scripting API manual
	C_color = new Array(
			elox_blue, 		// Front
			elox_blue, 		// Top
			elox_natural, 	// Back
			elox_black, 		// Bottom
			elox_red, 		// Left (For C_type==2 only)
			elox_blue		// Right (For C_type==2 only)
		);

	// Housing Brackets:
	C_numberOfHousingBracketsFront = new Array(1,2,0,0); // (Top, Bottom, Left, Right). Defines the number of housing brackets used on the front for each side panel. -1 will automatically place them pr. C_housingBracketMaxDistance mm.
	C_numberOfHousingBracketsBack = new Array(0,0,1,1);  // (Top, Bottom, Left, Right). Defines the number of housing brackets used on the back for each side panel.  -1 will automatically place them pr. C_housingBracketMaxDistance mm.
	C_useStudsForHousingBracketsOnFront = true;	// Uses M3x8mm Studs for housing brackets on front (instead of countersunk holes). Notice: This requires you to drill the thread out of the housing brackets on one side and use a washer and nut to fasten it!
	C_useStudsForHousingBracketsOnBack = false;	// Same as above, but for the back.

	// Front and Back Assembly Slots:
	C_useAssemblySlotsFront = new Array(true, false, false, false);	// (Top, Bottom, Left, Right). If true, cavities are used on the front panel to fit the top, bottom, left and right plates.
	C_useAssemblySlotsBack = new Array(false, false, false, false);	// (Top, Bottom, Left, Right). If true, cavities are used on the back panel to fit the top, bottom, left and right plates.
	C_depthOfCavitiesForSlotsFront = new Array(1,1,1,1);	// (Top, Bottom, Left, Right).
	C_depthOfCavitiesForSlotsBack = new Array(1,1,1,1);	// (Top, Bottom, Left, Right).
	C_assemblySlotDepthFront = new Array(1.5,1.5,1.5,1.5);	// (Top, Bottom, Left, Right). Assembly Slot Depths, front side
	C_assemblySlotDepthBack = new Array(1,1,1,1);				// (Top, Bottom, Left, Right). Assembly Slot Depths, back side

	// Ordering
	C_createOrder = false;			// If true, will create an order and add the accessories (profiles, assembly kits etc.)
	C_orderBlackItems = false;		// If true, will order accessories in black instead of natural color.

	// Additional features:
	C_extraFrontWidth = 10;	// If greater than zero, it will add this amount of space on left and right side of the front panel. This is useful to create "rack ears" (see also "C_rackEars" setting). If you want to create a true 19" unit, make sure 2* this value + C_width equals 483mm. A good choice is to set this value at 23mm and C_width = 437 => 23*2+437=483mm
	C_extraFrontHeight = 2;	// If creating a 1U rack unit, 43.60mm is a typical choice for the total height, so add 1.6 in total by setting this value to 0.8. (1U = 44.45mm or 1.75inch)
	C_rackEars = false;			// If true, adds holes for rack mounting. See also "C_extraFrontWidth"
	C_roundFrontCorners = true;	// If true, corners of the front panel are rounded by 2mm which fits the side or housing profiles.
	C_addEdgeGrinding = true;	// You probably want edges grinded on the end profiles (front and back) if you are not making a rack unit! Otherwise they are ugly from tool marks and often very sharp.
	C_addGuideEngravings = true;	// This will add thin, orange engraved lines for preview of where adjacent components (panels, profiles and brackets) are located on each side. Can be useful for positioning other elements after which they should be removed before ordering.

	C_panelNamesPrefix = "";		// A panel name prefix
	C_panelNamesSuffix = "";		// A panel name suffix

	// Exotic features:
	C_sideExpansionOffset = new Array(0,0,0,0); // (Top, Bottom, Left, Right). This offsets the top, bottom, left and right plates outwards if positive. By default the top and bottom plates are placed so their outer surface is flush with the side/housing profiles. When used with housing profile 1 this value should probably be -1!
	C_housingProfileRightHeight = 0;	// Must be less than C_height. If zero = off. Imposes various restrictions on the bottom plate, among other that it has to be bent a bit. Also, cannot be used with housing brackets on the bottom plate (front and back).
}








/***************************************
 * Configuration value getter-methods
 * These return detailed values for each
 * panel based on the global configuration 
 * variables.
 * Many could potentially be used to provide
 * more fine grained control.
 ***************************************/
var sidesMap = new Array(0,0,0,1,2,3);
function getThickness(sideNum)	{	// SideNum = {1,2,3,4,5,6}
	return C_thickness[sideNum-1];
}
function getColor(sideNum)	{	// SideNum = {1,2,3,4,5,6}
	return C_color[sideNum-1];
}
function assemblySlotDepth(sideNum,onBackSide)	{	// SideNum = {2,4,5,6}
	var useIt = onBackSide ? C_useAssemblySlotsBack[sidesMap[sideNum-1]] : C_useAssemblySlotsFront[sidesMap[sideNum-1]];
	var value = onBackSide ? C_assemblySlotDepthBack[sidesMap[sideNum-1]] : C_assemblySlotDepthFront[sidesMap[sideNum-1]];
	return !useIt ? 0 : value;
//	return !useIt ? 0 : getThickness(onBackSide?3:1)-C_frontBackSlotRemainingMaterial;	// Leave C_frontBackCavityRemainingMaterial mm of material
}
function assemblySlotDepthTol(sideNum,onBackSide)	{	// SideNum = {2,4,5,6}
	return 0.1;
}
function assemblySlotWidth(sideNum,onBackSide)	{	// SideNum = {2,4,5,6}
	var depthOfCavitiesForSlots = onBackSide ? C_depthOfCavitiesForSlotsBack[sidesMap[sideNum-1]] : C_depthOfCavitiesForSlotsFront[sidesMap[sideNum-1]];
	return getThickness(sideNum)-depthOfCavitiesForSlots;

}
function assemblySlotWidthTol(sideNum,onBackSide)	{	// SideNum = {2,4,5,6}
	return 0.1;
}
function sideCavityForAssemblySlotsDepthTolerance(sideNum)	{	// SideNum = {2,4,5,6}
	return 0.1;
}
function sideCavityDepthTolerance(sideNum)	{	// SideNum = {2 top,4 bottom, 5 left, 6 right}
	return 0.1;		
}
function getExpansionOffset(sideNum)	{	// SideNum = {2,4,5,6}
	return C_sideExpansionOffset[sidesMap[sideNum-1]];
}
function getNumberOfHousingBrackets(sideNum,onBackSide)	{	// SideNum = {2,4,5,6}
	var num = onBackSide ? C_numberOfHousingBracketsBack[sidesMap[sideNum-1]] : C_numberOfHousingBracketsFront[sidesMap[sideNum-1]];
	return num==-1 ? parseInt(getPanelWidth(sideNum)/C_housingBracketMaxDistance) : num;
}
function useStudsForHousingBrackets(sideNum,onBackSide)	{	// SideNum = {2,4,5,6}
	return onBackSide ? C_useStudsForHousingBracketsOnBack : C_useStudsForHousingBracketsOnFront;
}
function getEdgeProfile(sideNum)	{	// SideNum = {2,4,5,6}
	// Returns a characterization of the side profile or housing profile where it meets the front panel. Widths and heights of it's features (w1,h1,w2,h2,w3,isHousingProfile2)
	// It's imperative that the same profile is used in both sides of any given panel, otherwise the symmetry assumptions in the whole script are broken (which would affect the locations of housing bracket holes for instance.)
	// Also, notice that the configuration of housing profile 2 has other constraints such as that you cannot have profile 2 specified for adjacent sides.
	
	if (C_type==1)	{
		return new Array(10,1.2,7,1.5,10,false);	// Side Sections
	} else {
		var profile2 = false;

		switch(sideNum)	{
			case 2: 	// Top
				profile2 = C_housingProfile2Top;
			break;
			case 4: 	// Bottom
				profile2 = C_housingProfile2Bottom;
			break;
			case 5: 	// Left
				profile2 = C_housingProfile2Left;
			break;
			case 6: 	// Right
				profile2 = C_housingProfile2Right;
			break;
		}	

		if (profile2)	{
			return new Array(0,0,10,2,18,true);		// Housing Profile 2	
		} else {
			return new Array(16,1,10,1.5,13,false);	// Housing Profile 1
		}
	}
}







/************************
 * Guide object related functions
 * (Coordinates processing)
 *************************/

// A "Housing Profile 1" engraving, coordinate set:
var profile1Coordinates = [
[0,0,2],
[-16,0,1],
[-16,-1],
[-10,-1],
[-10,-1.6-1],
[-13,-1.6-1,1],
[-13,-4],
[-11.5,-5],
[-11.5,-4],
[-11.5+2,-4],
[-11.5+2,-5.2-1.3],
[-11.5+2+1,-5.2-1.3],
[-11.5+2+1,-5.2-1.3],

[-5.2-2,-5.2],
[-5.2-2,-5.2+0.3],
[-5.2-2-1,-5.2+0.3+1],
[-5.2-0.3-1,-5.2+2+1],
[-5.2-0.3,-5.2+2],
[-5.2+0.3,-5.2+2],
[-5.2+0.3+1,-5.2+2+1],

//[-5.2,-5.2],

[-5.2+2+1,-5.2+0.3+1],
[-5.2+2,-5.2+0.3],
[-5.2+2,-5.2-0.3],
[-5.2+2+1,-5.2-0.3-1],
[-5.2+0.3+1,-5.2-2-1],
[-5.2+0.3,-5.2-2],
[-5.2,-5.2-2],

[-5.2-1.3,-11.5+2+1],
[-5.2-1.3,-11.5+2+1],
[-5.2-1.3,-11.5+2],
[-4,-11.5+2],
[-4,-11.5],
[-5,-11.5],
[-4,-13],
[-1.6-1,-13,1],
[-1.6-1,-10],
[-1,-10],
[-1,-16],
[0,-16,1]
];

// A "Housing Profile 2" engraving, coordinate set:
var profile2Coordinates = [
[0,0,2],
[-16,0,1],
[-16,-1],
[-10,-1],
[-10,-1.6-1],
[-13,-1.6-1,1],
[-13,-4],
[-11.5,-5],
[-11.5,-4],
[-11.5+2,-4],
[-11.5+2,-5.2-1.3],
[-11.5+2+1,-5.2-1.3],
[-11.5+2+1,-5.2-1.3],

[-5.2-2,-5.2],
[-5.2-2,-5.2+0.3],
[-5.2-2-1,-5.2+0.3+1],
[-5.2-0.3-1,-5.2+2+1],
[-5.2-0.3,-5.2+2],
[-5.2+0.3,-5.2+2],
[-5.2+0.3+1,-5.2+2+1],

//[-5.2,-5.2],

[-5.2+2+1,-5.2+0.3+1],
[-5.2+2,-5.2+0.3],
[-5.2+2,-5.2-0.3],
[-5.2+2+1,-5.2-0.3-1],
[-5.2+0.3+1,-5.2-2-1],
[-5.2+0.3,-5.2-2],
[-5.2,-5.2-2],

[-5.2-1.3,-11.5+2+1],

[-5.2-1.3,-18],
[-2,-18],
[-2,-18+2.4],
[-2-1,-18+2.4],
[-2-1,-18+0.9],
[-2-3.2,-18+0.9],
[-2-3.2,-18+0.9+6.2],
[-2-1,-18+0.9+6.2],
[-2-1,-18+0.9+6.2-1.5],
[-2,-18+0.9+6.2-1.5],
[-2,-18+8],
[0,-18+8]
];

// A "Side Section 1" engraving, coordinate set:
var sideSection1Coordinates = [
[0,0,2],
[-10,0],
[-10,-1.2],
[-7,-1.2],
[-7,-1.2-1.6],
[-10,-1.2-1.6],
[-10,-1.2-1.6-1.2],
[-7,-1.2-1.6-1.2],
[-7,-1.2-1.6-1.2-1],
[-6,-1.2-1.6-1.2-1],

[-5,-4],
[-5-0.5,-4+0.5],
[-4-0.5,-4+1.5],
[-4,-4+1],
[-4+0.5,-4+1.5],
[-4+1.5,-4+0.5],
[-4+1,-4],
[-4+1.5,-4-0.5],
[-4+0.5,-5-0.5],
[-4,-5],
[-1.2-1.6-1.2-1,-6],
[-1.2-1.6-1.2-1,-7],

[-1.4,-7],
[-1.4,-7-1.8],
[-1.4-2.1,-7-1.8],
[-1.4-2.1,-7-1.8-1.5],

[-1.4,-10.3],
[-1.4,-10.3-2.5],
[-1.4-2.1,-10.3-2.5],
[-1.4-2.1,-10.3-2.5-1.5],

[-1.4,-14.3],
[-1.4,-14.3-1.8],
[-1.4-2.1,-14.3-1.8],
[-1.4-2.1,-14.3-1.8-4],

[-1.4,-20.1],

// Symmetri:

[-1.4,-42-(-20.1)],

[-1.4-2.1,-42-(-14.3-1.8-4)],
[-1.4-2.1,-42-(-14.3-1.8)],
[-1.4,-42-(-14.3-1.8)],
[-1.4,-42-(-14.3)],

[-1.4-2.1,-42-(-10.3-2.5-1.5)],
[-1.4-2.1,-42-(-10.3-2.5)],
[-1.4,-42-(-10.3-2.5)],
[-1.4,-42-(-10.3)],

[-1.4-2.1,-42-(-7-1.8-1.5)],
[-1.4-2.1,-42-(-7-1.8)],
[-1.4,-42-(-7-1.8)],
[-1.4,-42-(-7)],


[-1.2-1.6-1.2-1,-42-(-7)],
[-1.2-1.6-1.2-1,-42-(-6)],
[-4,-42-(-5)],
[-4+0.5,-42-(-5-0.5)],
[-4+1.5,-42-(-4-0.5)],
[-4+1,-42-(-4)],
[-4+1.5,-42-(-4+0.5)],
[-4+0.5,-42-(-4+1.5)],
[-4,-42-(-4+1)],
[-4-0.5,-42-(-4+1.5)],
[-5-0.5,-42-(-4+0.5)],
[-5,-42-(-4)],

[-6,-42-(-1.2-1.6-1.2-1)],
[-7,-42-(-1.2-1.6-1.2-1)],
[-7,-42-(-1.2-1.6-1.2)],
[-10,-42-(-1.2-1.6-1.2)],
[-10,-42-(-1.2-1.6)],
[-7,-42-(-1.2-1.6)],
[-7,-42-(-1.2)],
[-10,-42-(-1.2)],
[-10,-42-(0)],
[0,-42-(0),2]
];





// A "Side Section 2" engraving, coordinate set:
var sideSection2Coordinates = [
[0,0,2],
[-10,0],
[-10,-1.2],
[-7,-1.2],
[-7,-1.2-1.6],
[-10,-1.2-1.6],
[-10,-1.2-1.6-1.2],
[-7,-1.2-1.6-1.2],
[-7,-1.2-1.6-1.2-1],
[-6,-1.2-1.6-1.2-1],

[-5,-4],
[-5-0.5,-4+0.5],
[-4-0.5,-4+1.5],
[-4,-4+1],
[-4+0.5,-4+1.5],
[-4+1.5,-4+0.5],
[-4+1,-4],
[-4+1.5,-4-0.5],
[-4+0.5,-5-0.5],
[-4,-5],
[-1.2-1.6-1.2-1,-6],
[-1.2-1.6-1.2-1,-7+0.2],

[-1.4,-7+0.2],
[-1.4,-7-1.8+0.2],
[-1.4-2.1,-7-1.8+0.2],
[-1.4-2.1,-7-1.8-1.1+0.2],

[-1.4,-9.9+0.2],
[-1.4,-9.9-1.8+0.2],
[-1.4-2.1,-9.9-1.8+0.2],
[-1.4-2.1,-9.9-1.8-1.1+0.2],

[-1.4,-12.8+0.2],
[-1.4,-12.8-1.8+0.2],
[-1.4-2.1,-12.8-1.8+0.2],
[-1.4-2.1,-12.8-1.8-1.1+0.2],

[-1.4,-15.7+0.2],
[-1.4,-15.7-1.8+0.2],
[-1.4-2.1,-15.7-1.8+0.2],
[-1.4-2.1,-15.7-1.8-1.1+0.2],

[-1.4,-18.6+0.2],
[-1.4,-18.6-1.8+0.2],
[-1.4-2.1,-18.6-1.8+0.2],
[-1.4-2.1,-18.6-1.8-1.1+0.2],

[-1.4,-21.5+0.2],
[-1.4,-21.5-1.8+0.2],
[-1.4-2.1,-21.5-1.8+0.2],
[-1.4-2.1,-21.5-1.8-1.1+0.2],

[-1.4,-24.4+0.2],
[-1.4,-24.4-1.8+0.2],
[-1.4-2.1,-24.4-1.8+0.2],
[-1.4-2.1,-24.4-1.8-1.1+0.2],

[-1.4,-27.3+0.2],

// Symmetri:

[-1.4,-56-(-27.3)-0.2],

[-1.4-2.1,-56-(-24.4-1.8-1.1)-0.2],
[-1.4-2.1,-56-(-24.4-1.8)-0.2],
[-1.4,-56-(-24.4-1.8)-0.2],
[-1.4,-56-(-24.4)-0.2],

[-1.4-2.1,-56-(-21.5-1.8-1.1)-0.2],
[-1.4-2.1,-56-(-21.5-1.8)-0.2],
[-1.4,-56-(-21.5-1.8)-0.2],
[-1.4,-56-(-21.5)-0.2],

[-1.4-2.1,-56-(-18.6-1.8-1.1)-0.2],
[-1.4-2.1,-56-(-18.6-1.8)-0.2],
[-1.4,-56-(-18.6-1.8)-0.2],
[-1.4,-56-(-18.6)-0.2],

[-1.4-2.1,-56-(-15.7-1.8-1.1)-0.2],
[-1.4-2.1,-56-(-15.7-1.8)-0.2],
[-1.4,-56-(-15.7-1.8)-0.2],
[-1.4,-56-(-15.7)-0.2],

[-1.4-2.1,-56-(-12.8-1.8-1.1)-0.2],
[-1.4-2.1,-56-(-12.8-1.8)-0.2],
[-1.4,-56-(-12.8-1.8)-0.2],
[-1.4,-56-(-12.8)-0.2],

[-1.4-2.1,-56-(-9.9-1.8-1.1)-0.2],
[-1.4-2.1,-56-(-9.9-1.8)-0.2],
[-1.4,-56-(-9.9-1.8)-0.2],
[-1.4,-56-(-9.9)-0.2],

[-1.4-2.1,-56-(-7-1.8-1.1)-0.2],
[-1.4-2.1,-56-(-7-1.8)-0.2],
[-1.4,-56-(-7-1.8)-0.2],
[-1.4,-56-(-7)-0.2],

[-1.2-1.6-1.2-1,-56-(-7)-0.2],
[-1.2-1.6-1.2-1,-56-(-6)],
[-4,-56-(-5)],
[-4+0.5,-56-(-5-0.5)],
[-4+1.5,-56-(-4-0.5)],
[-4+1,-56-(-4)],
[-4+1.5,-56-(-4+0.5)],
[-4+0.5,-56-(-4+1.5)],
[-4,-56-(-4+1)],
[-4-0.5,-56-(-4+1.5)],
[-5-0.5,-56-(-4+0.5)],
[-5,-56-(-4)],

[-6,-56-(-1.2-1.6-1.2-1)],
[-7,-56-(-1.2-1.6-1.2-1)],
[-7,-56-(-1.2-1.6-1.2)],
[-10,-56-(-1.2-1.6-1.2)],
[-10,-56-(-1.2-1.6)],
[-7,-56-(-1.2-1.6)],
[-7,-56-(-1.2)],
[-10,-56-(-1.2)],
[-10,-56-(0)],
[0,-56-(0),2]
];


/**
 * Creates a HPGL engraving from input set of coordinates/radii
 */
function hpglFromCoordinates(coordinateSet)	{
	var hpgl = new HpglEngraving("hpgl", "", 5, 100);
	hpgl.ChangePen(hpgl.DefinePen(engrave_pastel_orange,engraver_0_2mm));
	var len = coordinateSet.length;

	for(var i=0; i<=len; i++)	{
		if (i==0)	{
			if (coordinateSet[0][2])	{	// there is a radius
				var cornerCoordinates = roundedCorner(coordinateSet[0][0],coordinateSet[0][1], coordinateSet[len-1][0],coordinateSet[len-1][1], coordinateSet[1][0],coordinateSet[1][1], coordinateSet[0][2]);
				hpgl.Start(cornerCoordinates[4],cornerCoordinates[5]);
			} else {	// none
				hpgl.Start(coordinateSet[0][0],coordinateSet[0][1]);
			}
		} else {
			if (coordinateSet[(i%len)][2])	{	// there is a radius
				var cornerCoordinates = roundedCorner(coordinateSet[(i%len)][0],coordinateSet[(i%len)][1], coordinateSet[(i-1)%len][0],coordinateSet[(i-1)%len][1], coordinateSet[(i+1)%len][0],coordinateSet[(i+1)%len][1], coordinateSet[(i%len)][2]);
				hpgl.LineTo(cornerCoordinates[2],cornerCoordinates[3]);
				hpgl.ArcToMP(cornerCoordinates[4],cornerCoordinates[5],cornerCoordinates[0],cornerCoordinates[1], cornerCoordinates[6]);
			} else {	// none
				hpgl.LineTo(coordinateSet[(i%len)][0],coordinateSet[(i%len)][1]);
			}
		}
	}
	
	hpgl.Finish();
	
	return hpgl;
}

/**
 * Calculates necessary coordinates for a rounded corner
 */
function roundedCorner(x,y, srcX,srcY, destX,destY, radius) {
	var result = new Array(0,0,0,0,0,0,1);	// centerX, centerY, srcAttachX, srcAttachY, destAttachX, destAttachY, rotationDirection
	
	var alpha1 = getAngleOfLine(x,srcX,y,srcY);
	var alpha2 = getAngleOfLine(x,destX,y,destY);

//	Print("alpha1="+alpha1/Math.PI*180+"\n");
//	Print("alpha2="+alpha2/Math.PI*180+"\n");
	
	var angleDiff = alpha2-alpha1;
	if (angleDiff < -Math.PI) {
		angleDiff+= 2*Math.PI;
	} else if (angleDiff > Math.PI)	{
		angleDiff-= 2*Math.PI;
	}
	
	var halfAngle = angleDiff/2;
//	Print("halfAngle="+halfAngle/Math.PI*180+"\n");
	
	var distFromXYpoint = Math.abs(radius / Math.sin(halfAngle));
//	Print("distFromXYpoint="+distFromXYpoint+"\n");

	var travelUpOnEachLine = Math.cos(halfAngle)*distFromXYpoint;
//	Print("travelUpOnEachLine="+travelUpOnEachLine+"\n");

	var angleOfCenterLine = alpha1+halfAngle;


	result[0] = translateXByAngle(x,angleOfCenterLine,distFromXYpoint);
	result[1] = translateYByAngle(y,angleOfCenterLine,distFromXYpoint);

	result[2] = translateXByAngle(x,alpha1,travelUpOnEachLine);
	result[3] = translateYByAngle(y,alpha1,travelUpOnEachLine);
	
	result[4] = translateXByAngle(x,alpha2,travelUpOnEachLine);
	result[5] = translateYByAngle(y,alpha2,travelUpOnEachLine);
	
	result[6] = halfAngle < 0 ? 1 : -1;
	
	return result;
}

/**
 * Returns the angle of a line given by it's x/y coordinates (two points)
 */
function getAngleOfLine(x1,x2,y1,y2)	{
	return (x2-x1)==0 ? (y2-y1 < 0?-1:1)*Math.PI/2 : Math.atan((y2-y1)/(x2-x1))+(x2-x1 < 0 ? Math.PI: 0);
}

/**
 * Translates an X value in 2D a certain distance at a certain angle
 */
function translateXByAngle(x,alpha,dist)	{
	return rounding(x+Math.cos(alpha)*dist);
}

/**
 * Translates a Y value in 2D a certain distance at a certain angle
 */
function translateYByAngle(y,alpha,dist)	{
	return rounding(y+Math.sin(alpha)*dist);
}

/**
 * Rounding to 5 digits
 */
function rounding(input)	{
	return Math.round(input*100000)/100000;
}

/**
 * Mirror coordinate set in 0,0
 */
function scaleCoordinates(coordinateSet,scaleX,scaleY)	{
	var len = coordinateSet.length;
	
	var result = new Array();
	
	for(var i=0; i<len; i++)	{
		result[i] = new Array(coordinateSet[i][0]*scaleX,coordinateSet[i][1]*scaleY,coordinateSet[i][2]);
	}
	return result;
}
function rotateCoordinates(coordinateSet,CWangle)	{
	var len = coordinateSet.length;
	
	var result = new Array();
	
	for(var i=0; i<coordinateSet.length; i++) {
		result[i] = new Array(
			coordinateSet[i][0] * Math.cos(-CWangle/180*Math.PI) - coordinateSet[i][1] * Math.sin(-CWangle/180*Math.PI),
			coordinateSet[i][0] * Math.sin(-CWangle/180*Math.PI) + coordinateSet[i][1] * Math.cos(-CWangle/180*Math.PI),
			coordinateSet[i][2]
		);
		
	}
	return result;
}

/**
 * Merge two "parallel" coordinate sets by appending all coordinates from revCoords in reverse order to fwdCoords and returning it as a copy
 */
function mergeFwdRevCoordinates(fwdCoords,revCoords)	{
	var result = new Array();
	
	var len = fwdCoords.length;
	for(var i=0; i<len; i++)	{
		result[i] = new Array(fwdCoords[i][0],fwdCoords[i][1],fwdCoords[i][2]);
	}
	
	var lenInner = revCoords.length;
	for(var i=lenInner-1; i>=0; i--)	{
		result[len] = new Array(revCoords[i][0],revCoords[i][1],revCoords[i][2]);
		len++;
	}
	
	return result;
	
}


/************************
 * Helper functions
 * (Helps proces values etc.)
 *************************/

/**
 * For the sides of the enclosure, this returns the offset of the outside perimeter of the box as marked by the side sections or housing profiles surface.
 */
function getPerimeterOffset(sideNum)	{	// sideNum = {2,4,5,6}
	switch(sideNum)	{
		case 2:
		case 4:
			return C_height/2;
		break;
		case 5:
		case 6:
			return C_width/2;
		break;
	}
}
/**
 * For the sides of the enclosure, this returns the offset of the given sides reverse side (facing inwards) relative to the center.
 */
function getReverseSideOffset(sideNum)	{	// sideNum = {2,4,5,6}
	return getFrontSideOffset(sideNum)-getThickness(sideNum);
}
/**
 * For the sides of the enclosure, this returns the offset of the given sides front side (facing outwards) relative to the center.
 */
function getFrontSideOffset(sideNum)	{	// sideNum = {2,4,5,6}
	return getPerimeterOffset(sideNum)+getExpansionOffset(sideNum);
}
/** 
 * Returns the width of the enclosure sides and ends
 * (Return zero for left and right sides in case of side sections are used.)
 */
function getPanelWidth(sideNum)	{	// sideNum = {1,2,3,4,5,6}

	switch(sideNum)	{
		case 1:
			return C_width+C_extraFrontWidth*2;
		break;
		case 3:
			return C_width;
		break;
		case 2:
		case 4:
			var edgeProfileData = getEdgeProfile(sideNum);

			if (sideNum==4 && lowerRightOffset>0)	{
				return Math.sqrt(Math.pow(lowerRightOffset,2)+Math.pow(getPerimeterOffset(5)*2-2*16,2))+5.9*2;
			} else {
				return C_width-edgeProfileData[2]*2;
			}
		break;
		case 5:
		case 6:
			var edgeProfileData = getEdgeProfile(sideNum);
			return C_type==1 ? 0 : C_height-edgeProfileData[2]*2-(sideNum==6?lowerRightOffset:0);
		break;
	}
}
/** 
 * Returns the height of the enclosure sides and ends
 */
function getPanelHeight(sideNum)	{	// sideNum = {1,2,3,4,5,6}

	switch(sideNum)	{
		case 1:
			return C_height+C_extraFrontHeight*2;
		break;
		case 3:
			return C_height;
		break;
		default:
			return C_depth-getThickness(1)-getThickness(3)+assemblySlotDepth(sideNum,false)+assemblySlotDepth(sideNum,true);
		break;
	}
}
/**
 * This will optimize the radius for cavities to the max and select the largest tool possible (to save costs)
 */
function setRadiusAndToolForCavity(cv)	{
	var width = cv.Width();
	var height = cv.Height();
	
	var min = width<height ? width : height;
	var rad = min/2>1.5 ? 1.5 : min/2;
	cv.SetCornerRadius(rad);
	
	if (rad==1.5)	{
		cv.SetTool(cutter_3_0mm);
	}
}


//distributes the cavity tolerance to the upper and lower cavity.
//four Modes here Side_Cavity_Tolerance_Mode: 
//1: all tolerance added to upper cavity (simplest)
//2: all tolerance added to under cavity if presented
//3: tolerance added equally to cavities if undercavity presented
//4: distributed in linear ratio
function GetUpperCavityTolerance(sumTolerance, upperCavityDepth, underCavityDepth)
{
 if (underCavityDepth < 0.0001) return sumTolerance;
 if (upperCavityDepth < 0.0001) return 0.0;
 if (Side_Cavity_Tolerance_Mode == 1) return sumTolerance;
 if (Side_Cavity_Tolerance_Mode == 2) return 0.0;
 if (Side_Cavity_Tolerance_Mode == 3) return sumTolerance/2.0;
 if (Side_Cavity_Tolerance_Mode == 4) return sumTolerance*upperCavityDepth/(upperCavityDepth+underCavityDepth);
}
function GetUnderCavityTolerance(sumTolerance, upperCavityDepth, underCavityDepth)
{
 if (upperCavityDepth < 0.0001) return sumTolerance;
 if (underCavityDepth < 0.0001) return 0.0;
 if (Side_Cavity_Tolerance_Mode == 1) return 0.0;
 if (Side_Cavity_Tolerance_Mode == 2) return sumTolerance;
 if (Side_Cavity_Tolerance_Mode == 3) return sumTolerance/2.0;
 if (Side_Cavity_Tolerance_Mode == 4) return sumTolerance*underCavityDepth/(upperCavityDepth+underCavityDepth);
}




/**
 * Creates top, bottom, left and right side panels engravings
 *
 * @param	integer		Location of panel (2=top, 4=bottom, 5=left, 6=right)
 * @return	HPGL engraving object
 */
function createHPGLGuideEngravingOfSide(sideNum)	{

	var width = getPanelWidth(sideNum);

	var centerX = width/2;
	var centerY = getThickness(sideNum)/2;
	var edgeProfileData = getEdgeProfile(sideNum);
	var coords = new Array();
	var cavDepthTol = sideCavityDepthTolerance(sideNum);
	

		// Cavities on sides for side sections and housing profiles (both top and bottom cavities are possible outcomes)
	for(var i=0;i<2;i++)	{	// i=0: Left, i=1: Right

		var upperCavityDepth = getFrontSideOffset(sideNum) - (getPerimeterOffset(sideNum)-edgeProfileData[1]);
		var underCavityDepth = (getPerimeterOffset(sideNum)-edgeProfileData[1]-edgeProfileData[3]) - getReverseSideOffset(sideNum);
		var cIdx=0;
		coords[i] = new Array();

		if (upperCavityDepth>0)	{
			var slotDepth = edgeProfileData[0]-edgeProfileData[2];
			var cavWidth = slotDepth+0.5;
			var cavOffset = (centerX-slotDepth+cavWidth/2);
			
			coords[i][cIdx++] = new Array((cavOffset-cavWidth/2)*(i&1?-1:1),centerY);
			coords[i][cIdx++] = new Array((cavOffset-cavWidth/2)*(i&1?-1:1),centerY-(upperCavityDepth+GetUpperCavityTolerance(cavDepthTol, upperCavityDepth, underCavityDepth)));
			coords[i][cIdx++] = new Array(centerX*(i&1?-1:1),centerY-(upperCavityDepth+GetUpperCavityTolerance(cavDepthTol, upperCavityDepth, underCavityDepth)));
		} else {
			coords[i][cIdx++] = new Array(centerX*(i&1?-1:1),centerY);
		}
	 	if (underCavityDepth>0)	{
			var slotDepth = edgeProfileData[4]-edgeProfileData[2]+0.5;
			var cavWidth = slotDepth+0.5;
			var cavOffset = (centerX-slotDepth+cavWidth/2);

			if (sideNum==4 && lowerRightOffset > 0)	{	// For consoles. Assuming only UNDER cavities!
				cavWidth = 6+0.5;
				cavOffset = (centerX-6+cavWidth/2);
			}
			coords[i][cIdx++] = new Array(centerX*(i&1?-1:1), -centerY+(underCavityDepth+GetUnderCavityTolerance(cavDepthTol, upperCavityDepth, underCavityDepth)));
			coords[i][cIdx++] = new Array((cavOffset-cavWidth/2)*(i&1?-1:1), -centerY+(underCavityDepth+GetUnderCavityTolerance(cavDepthTol, upperCavityDepth, underCavityDepth)));

			coords[i][cIdx++] = new Array((cavOffset-cavWidth/2)*(i&1?-1:1), -centerY);
		} else {
			coords[i][cIdx++] = new Array(centerX*(i&1?-1:1),-centerY);
		}
	}
	
	return hpglFromCoordinates(mergeFwdRevCoordinates(coords[1],coords[0])).SetHelpElement(true);
}





/**************************
 * Various computations and 
 * initializations.
 **************************/
if (C_type==1)	{
	var C_height = C_sideSectionType==1 ? 42 : 56;
	Print("C_height overruled by side section height, now being: " + C_height + "mm\n");
}
var lowerRightOffset = C_housingProfileRightHeight ? C_height-C_housingProfileRightHeight : 0;
var globalHousingBracketCount = 0;






/************************
 * Creator functions
 * (Creates panels and orders)
 *************************/

/**
 * Create end panels
 *
 * @param	string		Name of panel
 * @param	integer		Location of panel (1=front, 3=back)
 * @return	Frontpanel	Front panel object
 */
function createEnds(name, sideNum) {

	var width = getPanelWidth(sideNum);
	var height = getPanelHeight(sideNum);

		// Create panel:
	var fp = new Frontpanel(C_panelNamesPrefix+name+C_panelNamesSuffix, getThickness(sideNum), width, height, alu_elox);
	fp.SetMaterialColor(getColor(sideNum));
	if (sideNum==3 || C_roundFrontCorners)	{
		fp.SetCornerRadii(2,2,2,2);
	}
	
	if (lowerRightOffset)	{
		var cornerRadius=2;
		var rightHeight = height-lowerRightOffset;
		var leftIndent = 16;

		var alpha = Math.atan((height-rightHeight)/(width-leftIndent-cornerRadius));
		var cornerSinDist = Math.sin(alpha)*cornerRadius;
		var cornerCosDist = Math.cos(alpha)*cornerRadius;

		Print("alpha="+alpha/Math.PI*180+"\n");
//		Print("cornerSinDist="+cornerSinDist+"\n");
//		Print("cornerCosDist="+cornerCosDist+"\n");
		
		var MxO= sideNum==3 ? width : 0;
		var MxF= sideNum==3 ? -1 : 1;

		var dxf = new DxfContour("dxf-canvas1", "", 0, 100, 0);
		dxf.Start(MxO+MxF*0,cornerRadius);
		dxf.LineTo(MxO+MxF*0,height-cornerRadius);
		dxf.ArcToMP(MxO+MxF*(cornerRadius), height, MxO+MxF*(cornerRadius), height-cornerRadius, -1*MxF);
		dxf.LineTo(MxO+MxF*(width-cornerRadius),height);
		dxf.ArcToMP(MxO+MxF*(width), height-cornerRadius, MxO+MxF*(width-cornerRadius), height-cornerRadius, -1*MxF);
		dxf.LineTo(MxO+MxF*(width),(height-rightHeight)+cornerRadius);
		dxf.ArcToMP(MxO+MxF*(width-cornerRadius+cornerSinDist), (height-rightHeight)+cornerRadius-cornerCosDist, MxO+MxF*(width-cornerRadius), (height-rightHeight)+cornerRadius, -1*MxF);
		dxf.LineTo(MxO+MxF*(leftIndent+cornerSinDist), cornerRadius-cornerCosDist);
		dxf.ArcToMP(MxO+MxF*(leftIndent), 0, MxO+MxF*(leftIndent), cornerRadius, -1*MxF);
		dxf.LineTo(MxO+MxF*(cornerRadius), 0);
		dxf.ArcToMP(MxO+MxF*(0), cornerRadius, MxO+MxF*(cornerRadius), cornerRadius, -1*MxF);

		dxf.Finish();
		
		fp.SetBorderContour(dxf);
	}

		// Define center coordinates. These are the reference points for anything because the panels are symmetrical around the center axis
	var centerX = width/2;
	var centerY = height/2;

		// 4 Screw holes (depends on enclosure type!)
	switch(C_type)	{
		case 1: 	// Side Sections:
			var cOffsetX = getPerimeterOffset(5)-4;
			var cOffsetY = getPerimeterOffset(2)-4;

			for(var i=0;i<4;i++)	{	// 0=Upper Right, 1=Upper Left, 2=Lower Right, 3=Lower Left
				var el = new DrillHole("el", 3.20);
				fp.AddElement(el, centerX+cOffsetX*(i&1?-1:1), centerY+cOffsetY*(i&2?-1:1));
				el.SetCountersink(sink_74A_M3);
				M3count++;
			}
		break;
		case 2: 	// Housing Profiles
			var cOffsetX = getPerimeterOffset(5)-5.2;
			var cOffsetY = getPerimeterOffset(2)-5.2;

			for(var i=0;i<4;i++)	{	// 0=Upper Right, 1=Upper Left, 2=Lower Right, 3=Lower Left
				var el = new DrillHole("el", 5.00);
				fp.AddElement(el, centerX+cOffsetX*(i&1?-1:1)*(sideNum==3?-1:1), centerY+cOffsetY*(i&2?-1:1)+(i==2?lowerRightOffset:0));
				el.SetCountersink(sink_74A_M5);
			}
		break;
	}

	var sideIndex = new Array(2,4,6,5);	// Top, Bottom, Right, Left (don't change order!)
	var bottomAngle = Math.atan(lowerRightOffset/(getPerimeterOffset(5)*2-2*16))/Math.PI*180;
	//Print(bottomAngle);
	var bottomCutLength = Math.sqrt(Math.pow(lowerRightOffset,2)+Math.pow(getPerimeterOffset(5)*2-2*16,2))+1;
	//Print(bottomCutLength);

		// Assembly Slots, all sides:
	for(var i=0;i<4;i++)	{ // 0=top, 1=bottom, 2=Right, 3=Left
		var slotDepth = assemblySlotDepth(sideIndex[i], sideNum==3?true:false);
		if (slotDepth>0 && getPanelWidth(sideIndex[i]))	{	// calling getPanelWidth(sideIndex[i]) makes sure no cavities are made on panels with side sections (function returns 0 for such sides)
			var slotWidth = assemblySlotWidth(sideIndex[i], sideNum==3?true:false);
			var slotOffset = getReverseSideOffset(sideIndex[i])+slotWidth/2;

			var el = new Cavity("el");
			el.SetDepth(1);	// Temporary depth, necessary for scripting engine (v4.4)
			if (i<2)	{	// Top/bottom
				fp.AddElement(el, centerX, centerY+slotOffset*(i&1?-1:1)+(i==1?lowerRightOffset/2:0));
				el.MakeRectangular(getPanelWidth(sideIndex[i])+3, 3.0, slotDepth + assemblySlotDepthTol(sideIndex[i], sideNum==3?true:false), 0.5);
				el.SetHeight(slotWidth + assemblySlotWidthTol(sideIndex[i], sideNum==3?true:false));
				setRadiusAndToolForCavity(el);
				el.PutOnReverseSide();
				if (i==1 && lowerRightOffset > 0)	{
					el.SetAngle(bottomAngle*(sideNum==3?-1:1));
					el.SetWidth(bottomCutLength);

						// Add straight cavities:
					for(var j=0;j<2;j++)	{
						var el = new Cavity("el");
						el.SetDepth(1);	// Temporary depth, necessary for scripting engine (v4.4)
						
						fp.AddElement(el, centerX+(centerX-8-8/2-1)*(j&1?-1:1), centerY+(slotOffset*(i&1?-1:1)+(j==(sideNum==3?1:0)?lowerRightOffset:0)));
						el.MakeRectangular(8+2, 3.0, slotDepth + assemblySlotDepthTol(sideIndex[i], sideNum==3?true:false), 0.5);
						el.SetHeight(slotWidth + assemblySlotWidthTol(sideIndex[i], sideNum==3?true:false));
						setRadiusAndToolForCavity(el);
						el.PutOnReverseSide();
					}
				}
			} else {	// Left/Right
				fp.AddElement(el, centerX+slotOffset*(i&1?-1:1)*(sideNum==3?-1:1), centerY+(i==2?lowerRightOffset/2:0));	//(sideNum==3?-1:1) => Makes sure to mirror left/right on the BACK panel!
				el.MakeRectangular(3.0, getPanelWidth(sideIndex[i])+3, slotDepth + assemblySlotDepthTol(sideIndex[i], sideNum==3?true:false), 0.5);
				el.SetWidth(slotWidth + assemblySlotWidthTol(sideIndex[i], sideNum==3?true:false));
				setRadiusAndToolForCavity(el);
				el.PutOnReverseSide();
			}
		}
	}

		// Housing brackets, all sides
	for(var i=0;i<4;i++)	{ // 0=top, 1=bottom, 2=Right, 3=Left
		var housingBrackets = getNumberOfHousingBrackets(sideIndex[i], sideNum==3?true:false);
		if (housingBrackets>0 && getPanelWidth(sideIndex[i]) && (lowerRightOffset==0 || i!=1))	{	// (lowerRightOffset==0 || i!=1) used to filter the bottom housing profiles out in case they are angled (in the future, housing profiles _could_ be used with proper calculations of placements...)
			var housingBracketDist = getPanelWidth(sideIndex[i]) / (housingBrackets+1);
			var housingBracketStartOffset = housingBracketDist*(housingBrackets-1)/2;
			var housingBracketOffset = getReverseSideOffset(sideIndex[i])-6.5;
			var useStuds = useStudsForHousingBrackets(sideIndex[i], sideNum==3?true:false);
			
			globalHousingBracketCount+=housingBrackets;

			for(var a=0;a<housingBrackets;a++)	{
				if (useStuds)	{
					var el = new Bolt("el", "GU30", 8);
				} else {
				    M3count++;
					var el = new DrillHole("el", 3.00);
					el.SetCountersink(sink_74A_M3);
				}
				if (i<2)	{	// Top/bottom
					fp.AddElement(el, centerX-housingBracketStartOffset+housingBracketDist*a, centerY+housingBracketOffset*(i&1?-1:1));
					if (C_addGuideEngravings)	{
						fp.AddElement(new Rectangle("el", 10, 10).SetCornerRadius(0).SetTool(engraver_0_2mm).SetHelpElement(true),centerX-housingBracketStartOffset+housingBracketDist*a, centerY+(housingBracketOffset+1.5)*(i&1?-1:1));
					}
				} else {	// Left/Right
					fp.AddElement(el, centerX+housingBracketOffset*(i&1?-1:1)*(sideNum==3?-1:1), centerY-housingBracketStartOffset+housingBracketDist*a);	//(sideNum==3?-1:1) => Makes sure to mirror left/right on the BACK panel!
					if (C_addGuideEngravings)	{
						fp.AddElement(new Rectangle("el", 10, 10).SetCornerRadius(0).SetTool(engraver_0_2mm).SetHelpElement(true),centerX+(housingBracketOffset+1.5)*(i&1?-1:1)*(sideNum==3?-1:1), centerY-housingBracketStartOffset+housingBracketDist*a);
					}
				}
			}
		}
	}

		// Guide engravings:
	if (C_addGuideEngravings)	{
		for(var i=0;i<4;i++)	{ // 0=top, 1=bottom, 2=Right, 3=Left
			if (i<2)	{	// Top/bottom
				if (getPanelWidth(sideIndex[i]))	{

					fp.AddElement(
						createHPGLGuideEngravingOfSide(sideIndex[i]).SetAngle(i==1 && lowerRightOffset > 0 ? bottomAngle*(sideNum==3?-1:1) : (i==1 ? 180 : 0)),
						centerX, 
						centerY+(getFrontSideOffset(sideIndex[i])-getThickness(sideIndex[i])/2)*(i&1?-1:1)+(i==1?lowerRightOffset/2:0)
					);

					fp.AddElement(
						new TextEngraving("el", i==0?_("Top"):_("Bottom")).SetHelpElement(true).SetAlignment(align_center).SetTextHeight(1),
						centerX, 
						centerY+(getFrontSideOffset(sideIndex[i])-getThickness(sideIndex[i])/2)*(i&1?-1:1)+(i==1?lowerRightOffset/2:0)
					);
				}
			} else {
				if (getPanelWidth(sideIndex[i]))	{
					
					fp.AddElement(
						createHPGLGuideEngravingOfSide(sideIndex[i]).SetAngle((i==2?-90:90)*(sideNum==3?-1:1)),
						centerX+(getFrontSideOffset(sideIndex[i])-getThickness(sideIndex[i])/2)*(i&1?-1:1)*(sideNum==3?-1:1), 
						centerY+(i==2?lowerRightOffset/2:0)
					);
					
					fp.AddElement(
						new TextEngraving("el", i==2?_("Right"):_("Left")).SetHelpElement(true).SetAlignment(align_center).SetTextHeight(1).SetAngle(90),
						centerX+(getFrontSideOffset(sideIndex[i])-getThickness(sideIndex[i])/2)*(i&1?-1:1)*(sideNum==3?-1:1), 
						centerY+(i==2?lowerRightOffset/2:0)
					);
				}
			}
		}

			// Profiles:
		switch(C_type)	{
			case 1: 	// Side Sections:
				var profileCoordinates = C_sideSectionType==1 ? sideSection1Coordinates : sideSection2Coordinates;

				for(var i=0;i<2;i++)	{	// 0=Right, 1=Left
					var hpgl = hpglFromCoordinates(scaleCoordinates(profileCoordinates,i==0?-1:1,1));
					fp.AddElement(
						hpgl.SetHelpElement(true),
						centerX+getPerimeterOffset(5)*(i==0?-1:1), 
						centerY+getPerimeterOffset(2)
					);
				}
			break;
			case 2: 	// Housing Profiles
				for(var i=0;i<4;i++)	{ // 0=UL, 1=UR, 2=LR, 3=LL
					var profileCoordinates = profile1Coordinates;

					switch(i)	{
						case 0: 	// Upper left
							if (C_housingProfile2Top)	{
								profileCoordinates = rotateCoordinates(scaleCoordinates(profile2Coordinates,-1,1),90);
							} else if(C_housingProfile2Left)	{
								profileCoordinates = profile2Coordinates;
							}
						break;
						case 1: 	// Upper right
							if (C_housingProfile2Top)	{
								profileCoordinates = rotateCoordinates(scaleCoordinates(profile2Coordinates,-1,1),90);
							} else if(C_housingProfile2Right)	{
								profileCoordinates = profile2Coordinates;
							}
						break;
						case 2: 	// Lower right
							if (C_housingProfile2Bottom)	{
								profileCoordinates = rotateCoordinates(scaleCoordinates(profile2Coordinates,-1,1),90);
							} else if(C_housingProfile2Right)	{
								profileCoordinates = profile2Coordinates;
							}
						break;
						case 3: 	// Lower left
							if (C_housingProfile2Bottom)	{
								profileCoordinates = rotateCoordinates(scaleCoordinates(profile2Coordinates,-1,1),90);
							} else if(C_housingProfile2Left)	{
								profileCoordinates = profile2Coordinates;
							}
						break;
					}
					
					

					var hpgl = hpglFromCoordinates(scaleCoordinates(profileCoordinates,((i==0||i==3)?-1:1)*(sideNum==3?-1:1),((i==2||i==3)?-1:1)));
					fp.AddElement(
						hpgl.SetHelpElement(true),
						centerX+getPerimeterOffset(5)*((i==0||i==3)?-1:1)*(sideNum==3?-1:1), 
						centerY+getPerimeterOffset(2)*((i==2||i==3)?-1:1)+(i==2?lowerRightOffset:0)
					);
				}
			break;
		}
	}
	
		// FRONT special: D-holes for rack mounting:
	if (C_rackEars && sideNum==1)	{
		var cOffsetX = centerX-9.00;
		var cOffsetY = centerY-5.95;

		for(var i=0;i<4;i++)	{
			var el = new DHole("el", dhole_double, 10.50, 7.60);
			fp.AddElement(el, centerX+cOffsetX*(i&1?-1:1), centerY+cOffsetY*(i&2?-1:1));
			el.SetAngle(90);
		}
	}
	
		// Edge grinding
	if (C_addEdgeGrinding)	{
		fp.SetRemark(_("Please grind the edges."));
	}
		
	fp.UnsetModified().GridOff();	
	return fp;	
}

/**
 * Creates top, bottom, left and right side panels
 *
 * @param	string		Name of panel
 * @param	integer		Location of panel (2=top, 4=bottom, 5=left, 6=right)
 * @return	Frontpanel	Front panel object
 */
function createSides(name, sideNum)	{

	// Principle: The external side of these panels lie flush with side sections except offset by C_topBottomExpansionOffset
	
	var width = getPanelWidth(sideNum);
	var height = getPanelHeight(sideNum);
	var cavDepthTol = sideCavityDepthTolerance(sideNum);

		// Create panel:
	var fp = new Frontpanel(C_panelNamesPrefix+name+C_panelNamesSuffix, getThickness(sideNum), width, height, alu_elox);
	fp.SetMaterialColor(getColor(sideNum));

		// Define center coordinates. These are the reference points for anything because the panels are symmetrical around the center axis		
	var centerX = width/2;
	var centerY = height/2;
	var edgeProfileData = getEdgeProfile(sideNum);
    
		// Cavities on sides for side sections and housing profiles (both top and bottom cavities are possible outcomes)
	for(var i=0;i<2;i++)	{	// i=0: Left, i=1: Right

		var upperCavityDepth = getFrontSideOffset(sideNum) - (getPerimeterOffset(sideNum)-edgeProfileData[1]);
		var underCavityDepth = (getPerimeterOffset(sideNum)-edgeProfileData[1]-edgeProfileData[3]) - getReverseSideOffset(sideNum);
        //        if (upperCavityDepth > thicknessCodes[C_SchaefferHousings_UI_thickness]) upperCavityDepth=0;
	    //        if (underCavityDepth > thicknessCodes[C_SchaefferHousings_UI_thickness]) underCavityDepth=0;


		if (upperCavityDepth>0)	{
			var slotDepth = edgeProfileData[0]-edgeProfileData[2];
			var cavWidth = slotDepth+0.5;
			var cavOffset = (centerX-slotDepth+cavWidth/2);
			
			var el = new Cavity("el");
			el.SetDepth(1);	// Temporary depth, necessary for scripting engine (v4.4)
			fp.AddElement(el, centerX+cavOffset*(i&1?-1:1), centerY);

			if (1.5 + upperCavityDepth > getThickness(sideNum))
			    upperCavityDepth = getThickness(sideNum)-1.5;
			el.MakeRectangular(cavWidth, height+4, upperCavityDepth + GetUpperCavityTolerance(cavDepthTol, upperCavityDepth, underCavityDepth), 1.5);
			//el.MakeRectangular(cavWidth, height+4, 0.9, 1.5);
			setRadiusAndToolForCavity(el);
		}
	 	if (underCavityDepth>0)	{
			var slotDepth = edgeProfileData[4]-edgeProfileData[2]+0.5;
			var cavWidth = slotDepth+0.5;
			var cavOffset = (centerX-slotDepth+cavWidth/2);

			if (sideNum==4 && lowerRightOffset > 0)	{	// For consoles. Assuming only UNDER cavities!
				cavWidth = 6+0.5;
				cavOffset = (centerX-6+cavWidth/2);
			}

			var el = new Cavity("el");
			el.SetDepth(1);	// Temporary depth, necessary for scripting engine (v4.4)
			fp.AddElement(el, centerX+cavOffset*(i&1?-1:1), centerY);
			el.MakeRectangular(cavWidth, height+4, underCavityDepth + GetUnderCavityTolerance(cavDepthTol, upperCavityDepth, underCavityDepth), 1.5);
			setRadiusAndToolForCavity(el);
			el.PutOnReverseSide();

			if (sideNum==4 && lowerRightOffset > 0)	{	// For consoles. Assuming only UNDER cavities! This is the folding cavity
				var el = new Cavity("el");
				el.SetDepth(1);	// Temporary depth, necessary for scripting engine (v4.4)
				fp.AddElement(el, centerX+(centerX-6)*(i&1?-1:1), centerY);
				el.MakeRectangular(3, height+4, getThickness(sideNum)-0.5, 0.5);
				el.SetWidth(1);
				setRadiusAndToolForCavity(el);
				el.PutOnReverseSide();
			}
		}
		
		if (edgeProfileData[5])	{	// If housing profile 2, add screw holes:
			var numberOfScrewHoles = parseInt(height/100)+1;
			var screwHoleDist = height / numberOfScrewHoles;
			var screwHoleStartOffset = screwHoleDist*(numberOfScrewHoles-1)/2;

			for(var a=0;a<numberOfScrewHoles;a++)	{
			    M3count++;
				var el = new DrillHole("el", 3.00);
				fp.AddElement(el, centerX+(centerX-4)*(i&1?-1:1), centerY-screwHoleStartOffset+screwHoleDist*a);
				el.SetCountersink(sink_74A_M3);
			}
		}
	}

		// Cavity for Front and Back Assembly Slots:
	for(var i=0;i<2;i++)	{	// i=0:front, i=1: back
		var slotDepth = assemblySlotDepth(sideNum, i);
		if (slotDepth)	{
			var cavDepth = getThickness(sideNum)-assemblySlotWidth(sideNum, i);
			if (cavDepth>0)	{
				var cavHeight = slotDepth+0.5;
				if (cavHeight<3)	cavHeight=3;
				var cavOffset = centerY-slotDepth+cavHeight/2;
				var el = new Cavity("el");
				el.SetDepth(1);	// Temporary depth, necessary for scripting engine (v4.4)
				fp.AddElement(el, centerX, centerY+cavOffset*(i&1?1:-1));
				el.MakeRectangular(width+4, cavHeight, cavDepth + sideCavityForAssemblySlotsDepthTolerance(sideNum), 1.5);
				setRadiusAndToolForCavity(el);
			}
		}
	}

		// Housing brackets:
	if (lowerRightOffset==0 || sideNum!=4)	{
		for(var i=0;i<2;i++)	{	// i=0:front, i=1: back
			var housingBrackets = getNumberOfHousingBrackets(sideNum, i);
			if (housingBrackets>0)	{
				var housingBracketDist = width / (housingBrackets+1);
				var housingBracketStartOffset = housingBracketDist*(housingBrackets-1)/2;
				var housingBracketOffset = centerY-assemblySlotDepth(sideNum, i)-6.5;

				for(var a=0;a<housingBrackets;a++)	{
				    M3count++;
					var el = new DrillHole("el", 3.00);
					el.SetCountersink(sink_74A_M3);
					fp.AddElement(el, centerX-housingBracketStartOffset+housingBracketDist*a, centerY+housingBracketOffset*(i&1?1:-1));	// (i&1?1:-1) is "reversed" compared to createSides() but this is on purpose to make sure the "top" side of the panel matches the "back" of the enclosure.
					if (C_addGuideEngravings)	{
						fp.AddElement(new Rectangle("el", 10, 10).SetHelpElement(true).SetCornerRadius(0).SetTool(engraver_0_2mm),centerX-housingBracketStartOffset+housingBracketDist*a, centerY+(housingBracketOffset+1.5)*(i&1?1:-1));
					}
				}
			}
		}
	}
		
	if (C_addGuideEngravings)	{
		
			// Front:
		fp.AddElement(
			new Rectangle("el", sideNum>=5?getPanelHeight(1):getPanelWidth(1), getThickness(1)).SetHelpElement(true).SetCornerRadius(0).SetTool(engraver_0_2mm),
			centerX,
			centerY-(centerY-assemblySlotDepth(sideNum, false)+getThickness(1)/2)
		);
		fp.AddElement(
			new TextEngraving("el",_("Front")).SetHelpElement(true).SetAlignment(align_center).SetTextHeight(1),
			centerX,
			centerY-(centerY-assemblySlotDepth(sideNum, false)+getThickness(1)/2)+5
		);
		
			// Back:
		fp.AddElement(
			new Rectangle("el", sideNum>=5?getPanelHeight(3):getPanelWidth(3), getThickness(3)).SetHelpElement(true).SetCornerRadius(0).SetTool(engraver_0_2mm),
			centerX,
			centerY+(centerY-assemblySlotDepth(sideNum, true)+getThickness(3)/2)
		);
		fp.AddElement(
			new TextEngraving("el",_("Back")).SetAlignment(align_center).SetHelpElement(true).SetTextHeight(1),
			centerX,
			centerY+(centerY-assemblySlotDepth(sideNum, true)+getThickness(3)/2)-5
		);
		
			// Profiles:
		switch(C_type)	{
			case 1: 	// Side Sections:
				var profileSideWidth = 10;
			break;
			case 2: 	// Housing Profiles:
				var profileSideWidth = edgeProfileData[5]?18:16;
			break;
		}
		for(var i=0;i<2;i++)	{	// 0=Right, 1=Left
			fp.AddElement(
				new Rectangle("el", profileSideWidth, height-assemblySlotDepth(sideNum,false)-assemblySlotDepth(sideNum,true)).SetHelpElement(true).SetCornerRadius(0).SetTool(engraver_0_2mm),
				centerX+(centerX+edgeProfileData[2]-profileSideWidth/2)*(i&1?-1:1), 
				centerY+(assemblySlotDepth(sideNum,false)-assemblySlotDepth(sideNum,true))/2
			);
		}		
	}
		
	fp.UnsetModified().GridOff();
	return fp;
}


function orderAdditionalScrewsM3()	{
	if (M3count<=0) return;
	
	var package = Math.round( M3count /50 ); //this because I'm new to JS & just for the case, that the last line is not doing the intended
	while (package*50 < M3count) package++;
	
	if (C_orderBlackItems) {
	    if (C_SchaefferHousings_UI_thickness < 3 ) //6mm until for 2-3mm thickness
			OrderAddItem("GGRB3306",package);
		else           //8mm
		    OrderAddItem("GGRB3308",package);
	} else {
		if (C_SchaefferHousings_UI_thickness < 3 ) //6mm
			OrderAddItem("GGRB2306",package);
		else			//8mm
			OrderAddItem("GGRB2308",package);
	}
} 

/**
 * Create order
 */
function createOrder()	{
	var profileLengths = C_depth-getThickness(1)-getThickness(3);
	switch(C_type)	{
		case 1:
			var itemID = "GLGP10"+C_sideSectionType+(C_orderBlackItems?"3":"1");
			OrderAddItemWithLength(itemID, 2, profileLengths);	// Side Sections
			OrderAddItem("GGMS11"+(C_orderBlackItems?"2":"1")+"2",1);	// Assembly Kit
			M3count-=12; //8 M3 Screws already ordered;
		break;
		case 2:
			var profile2Cnt = 
				(C_housingProfile2Top?1:0)+
				(C_housingProfile2Left?1:0)+
				(C_housingProfile2Right?1:0)+
				(C_housingProfile2Bottom?1:0);
				
			if (profile2Cnt<=1)	{	// Only one side or none has housing profiles 2:
				var itemID = "GLGP201"+(C_orderBlackItems?"3":"1");
				OrderAddItemWithLength(itemID, profile2Cnt?2:4, profileLengths);	// Housing Profiles 1
			}
			if (profile2Cnt)	{	// There are housing profiles 2 involved:
				var itemID = "GLGP202"+(C_orderBlackItems?"3":"1");
				OrderAddItemWithLength(itemID, profile2Cnt>=2?4:2, profileLengths);	// Housing Profiles 2
				
					// Add small screws for side mounted on housing profiles 2 (must be M3x5, not longer!)
				OrderAddItem("GGMS17"+(C_orderBlackItems?"5":"4")+"2", 1);	// Square nuts
			}

			OrderAddItem("GGMS16"+(C_orderBlackItems?"2":"1")+"2",1);	// Assembly Kit
			M3count-=12; //8 M3 Screws already ordered;
		break;
	}
	
	orderAdditionalScrewsM3()    
	
		
	
		// Edge Grinding:
	if (C_addEdgeGrinding)	{
		OrderSetRemark(_("Notice, there are edge grindings on some panels."));
	}
	
		// Housing brackets:
	if (globalHousingBracketCount>0)	{
		if (globalHousingBracketCount<=4)	{
			OrderAddItem("GGWS0111",1);	// Housing brackets x4
		} else if (globalHousingBracketCount<=8)	{
			OrderAddItem("GGWS0112",1);	// Housing brackets x8
		} else if (globalHousingBracketCount<=12)	{
			OrderAddItem("GGWS0113",1);	// Housing brackets x12
		} else {
			OrderAddItem("GGWS0114",Math.ceil(globalHousingBracketCount/25));	// Housing brackets x25
		}
	}
}

// Rotation 90 degress both ways:
function rotatePanel(fp,rotation)	{
	var width = fp.Width();
	var height = fp.Height();
	
	var els = fp.Elements();
	switch(rotation)	{
		case 90:
			fp.SetWidth(height);
			fp.SetHeight(width);
			
			els.forEach(function(el){
				el.MoveTo(height-el.Y(),el.X());
				el.Rotate(90);
			});
		break;
		case -90:
		case 270:
			fp.SetWidth(height);
			fp.SetHeight(width);

			els.forEach(function(el){
				el.MoveTo(el.Y(),width-el.X());
				el.Rotate(-90);
			});
		break;
	}
}




// ###MARKER_PREMAKE###



/**************************
 * Execute...
 **************************/

// Front (1)
var fp1 = createEnds(_("Front"),1);
AddFrontpanel(fp1);

if (!C_dryRun)	{
	//rotatePanel(fp1,90);

	// Top (2)
	var fp2 = createSides(_("Top"),2);
	AddFrontpanel(fp2);

	// Back (3)
	var fp3 = createEnds(_("Back"),3);
	AddFrontpanel(fp3);

	// Bottom (4)
	var fp4 = createSides(_("Bottom"),4);
	AddFrontpanel(fp4);

	if (C_type==2)	{
		// Left (5)
		var fp5 = createSides(_("Left"),5);
		AddFrontpanel(fp5);

		// Right (6)
		var fp6 = createSides(_("Right"),6);
		AddFrontpanel(fp6);
	}



	// Create order with accessories:
	if (C_createOrder)	{
		createOrder();
	}
}








/***************************************************************
*  (c) 2013-2015 SKAARHOJ K/S, www.skaarhoj.com
*  Author: Kasper Skårhøj <kasper@skaarhoj.com>
*  All rights reserved
*
*  This script is free software; you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation; either version 2 of the License, or
*  (at your option) any later version.
*
*  The GNU General Public License can be found at
*  http://www.gnu.org/copyleft/gpl.html.
*
*  This script is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  This copyright notice MUST APPEAR in all copies of the script!
***************************************************************/
